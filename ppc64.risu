###############################################################################
# Copyright (c) IBM Corp, 2016
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
#
# Contributors:
#     Jose Ricardo Ziviani - initial implementation
#     based on aarch64.risu by Claudio Fontana
#     based on arm.risu by Peter Maydell
###############################################################################

# Input file for risugen defining PowerPC64 instructions
.mode ppc64

# Groups:
#
#   Versions:
#
#     P1-       Instruction introduced in POWER Architecture and dropped in later architectures. # Not included.
#     P1        Instruction introduced in POWER Architecture.
#     P2        Instruction introduced in POWER2 Architecture.
#     PPC       Instruction introduced in PowerPC Architecture prior to v2.00.
#     v2.00     Instruction introduced in PowerPC Architecture Version 2.00.
#     v2.01     Instruction introduced in PowerPC Architecture Version 2.01.
#     v2.02     Instruction introduced in PowerPC Architecture Version 2.02.
#     v2.03     Instruction introduced in Power ISA Version 2.03.
#     v2.04     Instruction introduced in Power ISA Version 2.04.      # None.
#     v2.05     Instruction introduced in Power ISA Version 2.05.
#     v2.06     Instruction introduced in Power ISA Version 2.06.
#     v2.07     Instruction introduced in Power ISA Version 2.07.
#     v3.0      Instruction introduced in Power ISA Version 3.0.
#     v3.0-     Instruction introduced in Power ISA Version 3.0 and dropped in later architectures. # Not included.
#     v3.0B     Instruction introduced in Power ISA Version 3.0B.      # In Skip group.
#     v3.0C     Instruction introduced in Power ISA Version 3.0C.      # In Skip group.
#     v3.1      Instruction introduced in Power ISA Version 3.1.       # In Skip group.
#     v3.1B     Instruction introduced in Power ISA Version 3.1.       # In Skip group.
#
#   Book/Facility:
#
#     book:I
#
#       Branch
#       Fixed-Point
#       Floating-Point
#       Decimal_Floating-Point
#       Vector
#       Vector-Scalar_Extension
#
#     book:II           # In Skip group.
#
#       Storage_Control
#       Time_Base
#       Branch_History_Rolling_Buffer
#
#     book:III          # In Skip group.
#
#       Branch
#       Fixed-Point
#       Storage_Control
#       Interrupts
#       Timer
#       Dynamic_Execution_Control
#       Debug
#       Performance_Monitor
#       Processor_Control
#
#   OpenPOWER Compliancy Subsets:   # Not a risu group
#
#     X... Instruction included in the Scalar Fixed-Point Compliancy subset
#     .X.. Instruction included in the Scalar Fixed-Point + Floating-Point Compliancy subset.
#     ..X. Instruction included in the Linux Compliancy subset.
#     ...X Instruction included in the AIX Compliancy subset.
#
#   Linux Optional Category:
#
#     AMO    Instruction part of Atomic Memory Operations category.
#     BFP128 Instruction part of Quad-Precision Floating-Point category.
#     BHRB   Instruction part of Branch History Rolling Buffer category.
#     DFP    Instruction part of Decimal Floating-Point category.
#     EBB    Instruction part of Event-Based Branch category.
#     MMA    Instruction part of Matrix-Multiplication Assist category.
#
#   Always Optional Category:
#
#     MMA    Instruction part of Matrix-Multiplication Assist category.
#
#   Privilege:
#
#     P    Denotes an instruction that is treated as privileged.
#     O    Denotes an instruction that is treated as privileged or nonprivileged (or hypervisor-privileged for mtspr), depending on the SPR or PMR number.
#     PI   Denotes an instruction that is illegal in privileged state. # ldmx was withdrawn.
#     HV   Denotes an instruction that can be executed only in hypervisor state.
#     UV   Denotes an instruction that can be executed only in ultravisor state.
#
#   Mode Dependency:
#
#     CT   If the instruction tests the Count Register, it tests the low-order 32 bits in 32-bit mode and all 64 bits in 64-bit mode.
#     SR   The setting of status registers (such as XER and CR0) is mode-dependent.
#     _64  The instruction can be executed only in 64-bit mode.
#
#   Formats:
#
#     format:8LS:D    format:MD         format:XFL
#     format:8RR-XX4  format:MDS        format:XFX
#     format:8RR:D    format:MLS:D      format:XL
#     format:8RR:XX4  format:MMIRR:XX3  format:XO
#     format:A        format:MRR:*      format:XS
#     format:B        format:SC         format:XX2
#     format:D        format:SendX      format:XX3
#     format:DQ       format:VA         format:XX4
#     format:DS       format:VC         format:Z22
#     format:DX       format:VN         format:Z23
#     format:I        format:VX
#     format:M        format:X
#
#   Custom groups: not from the PowerPC ISA document
#
#     AltiVec  Instruction supported in all CPUs that support vector instructions.
#     Optional Instruction not defined in many/all? 32-bit PowerPC CPUs.
#     PPC64    Instruction only defined for 64-bit PowerPC CPUs.
#     Skip     Ignore this instruction.
#
# Encodings:
#
#   PPC64LE  Instruction supported in little-endian and big-endian modes.
#   PPC64BE  Instruction supported in big-endian mode only.
#

@ format:XO, book:I, page:77, Fixed-Point, P1, SR, add[o][.] # Add
ADD PPC64LE 011111 rt:5 ra:5 rb:5 01000010100 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
ADDd PPC64LE 011111 rt:5 ra:5 rb:5 01000010101 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
ADDo PPC64LE 011111 rt:5 ra:5 rb:5 11000010100 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
ADDod PPC64LE 011111 rt:5 ra:5 rb:5 11000010101 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:XO, book:I, page:78, Fixed-Point, P1, SR, addc[o][.] # Add Carrying
ADDC PPC64LE 011111 rt:5 ra:5 rb:5 00000010100 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
ADDCd PPC64LE 011111 rt:5 ra:5 rb:5 00000010101 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
ADDCo PPC64LE 011111 rt:5 ra:5 rb:5 10000010100 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
ADDCod PPC64LE 011111 rt:5 ra:5 rb:5 10000010101 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:XO, book:I, page:78, Fixed-Point, P1, SR, adde[o][.] # Add Extended
ADDE PPC64LE 011111 rt:5 ra:5 rb:5 00100010100 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
ADDEd PPC64LE 011111 rt:5 ra:5 rb:5 00100010101 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
ADDEo PPC64LE 011111 rt:5 ra:5 rb:5 10100010100 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
ADDEod PPC64LE 011111 rt:5 ra:5 rb:5 10100010101 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:Z23, book:I, page:80, Fixed-Point, v3.0B, Skip, addex # Add Extended using alternate carry bit
ADDEX PPC64LE 011111 a:17 101010100

@ format:XO, book:I, page:118, Fixed-Point, v2.06, addg6s # Add and Generate Sixes
ADDG6S PPC64LE 011111 rt:5 ra:5 rb:5 00010010100 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:D, book:I, page:76, Fixed-Point, P1, addi # Add Immediate
ADDI PPC64LE 001110 rt:5 ra:5 imm:16 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }

@ format:D, book:I, page:77, Fixed-Point, P1, SR, addic # Add Immediate Carrying
ADDIC PPC64LE 001100 rt:5 ra:5 imm:16 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }

@ format:D, book:I, page:77, Fixed-Point, P1, SR, addic. # Add Immediate Carrying and Record
ADDICd PPC64LE 001101 rt:5 ra:5 imm:16 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }

@ format:D, book:I, page:76, Fixed-Point, P1, addis # Add Immediate Shifted
ADDIS PPC64LE 001111 rt:5 ra:5 imm:16 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }

@ format:XO, book:I, page:79, Fixed-Point, P1, SR, addme[o][.] # Add to Minus One Extended
ADDME PPC64LE 011111 rt:5 ra:5 0000000111010100 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }
ADDMEd PPC64LE 011111 rt:5 ra:5 0000000111010101 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }
ADDMEo PPC64LE 011111 rt:5 ra:5 0000010111010100 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }
ADDMEod PPC64LE 011111 rt:5 ra:5 0000010111010101 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }

@ format:DX, book:I, page:76, Fixed-Point, v3.0, addpcis # Add PC Immediate Shifted
ADDPCIS PPC64LE 010011 rt:5 db:5 da:10 00010 dc:1 \
!constraints { $rt != 1 && $rt != 13; }

@ format:XO, book:I, page:79, Fixed-Point, P1, SR, addze[o][.] # Add to Zero Extended
ADDZE PPC64LE 011111 rt:5 ra:5 0000000110010100 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }
ADDZEd PPC64LE 011111 rt:5 ra:5 0000000110010101 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }
ADDZEo PPC64LE 011111 rt:5 ra:5 0000010110010100 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }
ADDZEod PPC64LE 011111 rt:5 ra:5 0000010110010101 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }

@ format:X, book:I, page:100, Fixed-Point, P1, SR, and[.] # AND
AND PPC64LE 011111 rs:5 ra:5 rb:5 00000111000 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }
ANDd PPC64LE 011111 rs:5 ra:5 rb:5 00000111001 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }

@ format:X, book:I, page:101, Fixed-Point, P1, SR, andc[.] # AND with Complement
ANDC PPC64LE 011111 ra:5 rs:5 rb:5 00001111000 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }
ANDCd PPC64LE 011111 ra:5 rs:5 rb:5 00001111001 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }

@ format:D, book:I, page:99, Fixed-Point, P1, SR, andi. # AND Immediate
ANDId PPC64LE 011100 rs:5 ra:5 imm:16 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13 && $imm >= 0; }

@ format:D, book:I, page:99, Fixed-Point, P1, SR, andis. # AND Immediate Shifted
ANDISd PPC64LE 011101 rs:5 ra:5 imm:16 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13 && $imm >= 0; }

@ format:I, book:I, page:41, Branch, P1, Skip, b[l][a] # Branch
B PPC64LE 010010 a:24 00
Ba PPC64LE 010010 a:24 10
Bl PPC64LE 010010 a:24 01
Bla PPC64LE 010010 a:24 11

@ format:B, book:I, page:41, Branch, P1, CT, Skip, bc[l][a] # Branch Conditional
BC PPC64LE 010000 a:24 00
BCa PPC64LE 010000 a:24 10
BCl PPC64LE 010000 a:24 01
BCla PPC64LE 010000 a:24 11

@ format:XL, book:I, page:42, Branch, P1, CT, Skip, bcctr[l] # Branch Conditional to Count Register
BCCTR PPC64LE 010011 a:10 000 b:2 10000100000
BCCTRl PPC64LE 010011 a:10 000 b:2 10000100001

@ format:VX, book:I, page:483, Vector, v2.07, bcdadd. # Decimal Add Modulo
BCDADDd PPC64LE 000100 vrt:5 vra:5 vrb:5 1 ps:1 000000001

@ format:VX, book:I, page:485, Vector, v3.0, bcdcfn. # Decimal Convert From National
BCDCFNd PPC64LE 000100 vrt:5 00111 vrb:5 1 ps:1 110000001

@ format:VX, book:I, page:490, Vector, v3.0, bcdcfsq. # Decimal Convert From Signed Quadword
BCDCFSQd PPC64LE 000100 vrt:5 00010 vrb:5 1 ps:1 110000001

@ format:VX, book:I, page:486, Vector, v3.0, bcdcfz. # Decimal Convert From Zoned
BCDCFZd PPC64LE 000100 vrt:5 00110 vrb:5 1 ps:1 110000001

@ format:VX, book:I, page:494, Vector, v3.0, bcdcpsgn. # Decimal Copy Sign
BCDCPSGNd PPC64LE 000100 vrt:5 vra:5 vrb:5 01101000001

@ format:VX, book:I, page:488, Vector, v3.0, bcdctn. # Decimal Convert To National
BCDCTNd PPC64LE 000100 vrt:5 00101 vrb:5 10110000001

@ format:VX, book:I, page:491, Vector, v3.0, bcdctsq. # Decimal Convert To Signed Quadword
BCDCTSQd PPC64LE 000100 vrt:5 00000 vrb:5 10110000001

@ format:VX, book:I, page:489, Vector, v3.0, bcdctz. # Decimal Convert To Zoned
BCDCTZd PPC64LE 000100 vrt:5 00100 vrb:5 1 ps:1 110000001

@ format:VX, book:I, page:496, Vector, v3.0, bcds. # Decimal Shift
BCDSd PPC64LE 000100 vrt:5 vra:5 vrb:5 1 ps:1 011000001

@ format:VX, book:I, page:495, Vector, v3.0, bcdsetsgn. # Decimal Set Sign
BCDSETSGNd PPC64LE 000100 vrt:5 11111 vrb:5 1 ps:1 110000001

@ format:VX, book:I, page:498, Vector, v3.0, bcdsr. # Decimal Shift and Round
BCDSRd PPC64LE 000100 vrt:5 vra:5 vrb:5 1 ps:1 111000001

@ format:VX, book:I, page:483, Vector, v2.07, bcdsub. # Decimal Subtract Modulo
BCDSUBd PPC64LE 000100 vrt:5 vra:5 vrb:5 1 ps:1 001000001

@ format:VX, book:I, page:499, Vector, v3.0, bcdtrunc. # Decimal Truncate
BCDTRUNCd PPC64LE 000100 vrt:5 vra:5 vrb:5 1 ps:1 100000001

@ format:VX, book:I, page:497, Vector, v3.0, bcdus. # Decimal Unsigned Shift
BCDUSd PPC64LE 000100 vrt:5 vra:5 vrb:5 10010000001

@ format:VX, book:I, page:500, Vector, v3.0, bcdutrunc. # Decimal Unsigned Truncate
BCDUTRUNCd PPC64LE 000100 vrt:5 vra:5 vrb:5 10101000001

@ format:XL, book:I, page:42, Branch, P1, CT, Skip, bclr[l] # Branch Conditional to Link Register
BCLR PPC64LE 010011 a:10 000 b:2 00000100000
BCLRl PPC64LE 010011 a:10 000 b:2 00000100001

@ format:XL, book:I, page:43, Branch, v2.07, Skip, bctar[l] # Branch Conditional to Branch Target Address Register
BCTAR PPC64LE 010011 a:10 000 b:2 10001100000
BCTARl PPC64LE 010011 a:10 000 b:2 10001100001

@ format:X, book:I, page:105, Fixed-Point, v2.06, bpermd # Bit Permute Doubleword
BPERMD PPC64LE 011111 rs:5 ra:5 rb:5 00111111000 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }

@ format:X, book:I, page:119, Fixed-Point, v3.1, Skip, brd # Byte-Reverse Doubleword
BRD PPC64LE 011111 a:10 0000000101110110

@ format:X, book:I, page:119, Fixed-Point, v3.1, Skip, brh # Byte-Reverse Halfword
BRH PPC64LE 011111 a:10 0000000110110110

@ format:X, book:I, page:119, Fixed-Point, v3.1, Skip, brw # Byte-Reverse Word
BRW PPC64LE 011111 a:10 0000000100110110

@ format:X, book:I, page:117, Fixed-Point, v2.06, cbcdtd # Convert Binary Coded Decimal To Declets
CBCDTD PPC64LE 011111 rs:5 ra:5 0000001001110100 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:X, book:I, page:117, Fixed-Point, v2.06, cdtbcd # Convert Declets To Binary Coded Decimal
CDTBCD PPC64LE 011111 rs:5 ra:5 0000001000110100 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:X, book:I, page:106, Fixed-Point, v3.1, Skip, cfuged # Centrifuge Doubleword
CFUGED PPC64LE 011111 a:15 00110111000

@ format:X, book:I, page:1113, Branch_History_Rolling_Buffer, v2.07, BHRB, clrbhrb # Clear BHRB
CLRBHRB PPC64LE 011111 00000000000000001101011100

@ format:X, book:I, page:93, Fixed-Point, P1, cmp # Compare
CMP PPC64LE 011111 bf:3 0 l:1 ra:5 rb:5 00000000000 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13; }

@ format:X, book:I, page:102, Fixed-Point, v2.05, cmpb # Compare Bytes
CMPB PPC64LE 011111 rs:5 ra:5 rb:5 01111111000 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }

@ format:X, book:I, page:95, Fixed-Point, v3.0, cmpeqb # Compare Equal Byte
CMPEQB PPC64LE 011111 bf:3 00 ra:5 rb:5 00111000000 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13; }

@ format:D, book:I, page:93, Fixed-Point, P1, cmpi # Compare Immediate
CMPI PPC64LE 001011 bf:3 0 l:1 ra:5 imm:16 \
!constraints { $ra != 1 && $ra != 13; }

@ format:X, book:I, page:93, Fixed-Point, P1, cmpl # Compare Logical
CMPL PPC64LE 011111 bf:3 0 l:1 ra:5 rb:5 00001000000 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13; }

@ format:D, book:I, page:93, Fixed-Point, P1, cmpli # Compare Logical Immediate
CMPLI PPC64LE 001010 bf:3 0 l:1 ra:5 imm:16 \
!constraints { $ra != 1 && $ra != 13 && $imm >= 0; }

@ format:X, book:I, page:94, Fixed-Point, v3.0, cmprb # Compare Ranged Byte
CMPRB PPC64LE 011111 bf:3 0 l:1 ra:5 rb:5 00110000000 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13; }

@ format:X, book:I, page:104, Fixed-Point, PPC, SR, PPC64, cntlzd[.] # Count Leading Zeros Doubleword
CNTLZD PPC64LE 011111 rs:5 ra:5 0000000001110100 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }
CNTLZDd PPC64LE 011111 rs:5 ra:5 0000000001110101 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:X, book:I, page:105, Fixed-Point, v3.1, Skip, cntlzdm # Count Leading Zeros Doubleword under bit Mask
CNTLZDM PPC64LE 011111 a:15 00001110110

@ format:X, book:I, page:102, Fixed-Point, P1, SR, cntlzw[.] # Count Leading Zeros Word
CNTLZW PPC64LE 011111 rs:5 ra:5 0000000000110100 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }
CNTLZWd PPC64LE 011111 rs:5 ra:5 0000000000110101 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:X, book:I, page:104, Fixed-Point, v3.0, cnttzd[.] # Count Trailing Zeros Doubleword
CNTTZD PPC64LE 011111 rs:5 ra:5 0000010001110100 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }
CNTTZDd PPC64LE 011111 rs:5 ra:5 0000010001110101 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:X, book:I, page:105, Fixed-Point, v3.1, Skip, cnttzdm # Count Trailing Zeros Doubleword under bit Mask
CNTTZDM PPC64LE 011111 a:15 10001110110

@ format:X, book:I, page:102, Fixed-Point, v3.0, cnttzw[.] # Count Trailing Zeros Word
CNTTZW PPC64LE 011111 rs:5 ra:5 0000010000110100 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }
CNTTZWd PPC64LE 011111 rs:5 ra:5 0000010000110101 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:X, book:II, page:1078, Storage_Control, v3.0, Skip, copy # Copy
COPY PPC64LE 0111110000 a:11 11000001100

@ format:X, book:II, page:1079, Storage_Control, v3.0, Skip, cpabort # Copy-Paste Abort
CPABORT PPC64LE 01111100000000000000011010001100

@ format:XL, book:I, page:44, Branch, P1, crand # Condition Register AND
CRAND PPC64LE 010011 bt:5 ba:5 bb:5 01000000010

@ format:XL, book:I, page:45, Branch, P1, crandc # Condition Register AND with Complement
CRANDC PPC64LE 010011 bt:5 ba:5 bb:5 00100000010

@ format:XL, book:I, page:45, Branch, P1, creqv # Condition Register Equivalent
CREQV PPC64LE 010011 bt:5 ba:5 bb:5 01001000010

@ format:XL, book:I, page:44, Branch, P1, crnand # Condition Register NAND
CRNAND PPC64LE 010011 bt:5 ba:5 bb:5 00111000010

@ format:XL, book:I, page:45, Branch, P1, crnor # Condition Register NOR
CRNOR PPC64LE 010011 bt:5 ba:5 bb:5 00001000010

@ format:XL, book:I, page:44, Branch, P1, cror # Condition Register OR
CROR PPC64LE 010011 bt:5 ba:5 bb:5 01110000010

@ format:XL, book:I, page:45, Branch, P1, crorc # Condition Register OR with Complement
CRORC PPC64LE 010011 bt:5 ba:5 bb:5 01101000010

@ format:XL, book:I, page:44, Branch, P1, crxor # Condition Register XOR
CRXOR PPC64LE 010011 bt:5 ba:5 bb:5 00110000010

@ format:X, book:I, page:210, Decimal_Floating-Point, v2.05, DFP, dadd[.] # DFPAdd
DADD PPC64LE 111011 frt:5 fra:5 frb:5 00000000100
DADDd PPC64LE 111011 frt:5 fra:5 frb:5 00000000101

@ format:X, book:I, page:210, Decimal_Floating-Point, v2.05, DFP, daddq[.] # DFPAdd Quad
DADDQ PPC64LE 111111 frtp:5 frap:5 frbp:5 00000000100
DADDQd PPC64LE 111111 frtp:5 frap:5 frbp:5 00000000101

@ format:X, book:I, page:86, Fixed-Point, v3.0, darn # Deliver A Random Number
DARN PPC64LE 011111 rt:5 000 l:2 0000010111100110 \
!constraints { $rt != 1 && $rt != 13 && $l != 3; }

@ format:X, book:II, page:1074, Storage_Control, PPC, Skip, dcbf # Data Cache Block Flush
DCBF PPC64LE 011111000 a:12 00010101100

@ format:X, book:II, page:1073, Storage_Control, PPC, Skip, dcbst # Data Cache Block Store
DCBST PPC64LE 01111100000 a:10 00001101100

@ format:X, book:II, page:1071, Storage_Control, PPC, Skip, dcbt # Data Cache Block Touch
DCBT PPC64LE 011111 a:15 01000101100

@ format:X, book:II, page:1072, Storage_Control, PPC, Skip, dcbtst # Data Cache Block Touch for Store
DCBTST PPC64LE 011111 a:15 00111101100

@ format:X, book:II, page:1073, Storage_Control, P1, Skip, dcbz # Data Cache Block set to Zero
DCBZ PPC64LE 01111100000 a:10 11111101100

@ format:X, book:I, page:235, Decimal_Floating-Point, v2.06, DFP, dcffix[.] # DFP Convert From Fixed
DCFFIX PPC64LE 111011 frt:5 00000 frb:5 11001000100
DCFFIXd PPC64LE 111011 frt:5 00000 frb:5 11001000101

@ format:X, book:I, page:235, Decimal_Floating-Point, v2.05, DFP, dcffixq[.] # DFP Convert From Fixed Quad
DCFFIXQ PPC64LE 111111 frt:5 00000 frbp:5 11001000100
DCFFIXQd PPC64LE 111111 frt:5 00000 frbp:5 11001000101

@ format:X, book:I, page:236, Decimal_Floating-Point, v3.1, DFP, Skip, dcffixqq # DFP Convert From Fixed Quadword Quad
DCFFIXQQ PPC64LE 111111 a:5 00000 b:5 11111000100

@ format:X, book:I, page:216, Decimal_Floating-Point, v2.05, DFP, dcmpo # DFP Compare Ordered
DCMPO PPC64LE 111011 bf:3 00 fra:5 frb:5 00100000100

@ format:X, book:I, page:216, Decimal_Floating-Point, v2.05, DFP, dcmpoq # DFP Compare Ordered Quad
DCMPOQ PPC64LE 111111 bf:3 00 frap:5 frbp:5 00100000100

@ format:X, book:I, page:215, Decimal_Floating-Point, v2.05, DFP, dcmpu # DFP Compare Unordered
DCMPU PPC64LE 111011 bf:3 00 fra:5 frb:5 10100000100

@ format:X, book:I, page:215, Decimal_Floating-Point, v2.05, DFP, dcmpuq # DFP Compare Unordered Quad
DCMPUQ PPC64LE 111111 bf:3 00 frap:5 frbp:5 10100000100

@ format:X, book:I, page:233, Decimal_Floating-Point, v2.05, DFP, dctdp[.] # DFP Convert To DFP Long
DCTDP PPC64LE 111011 frt:5 00000 frb:5 01000000100
DCTDPd PPC64LE 111011 frt:5 00000 frb:5 01000000101

@ format:X, book:I, page:237, Decimal_Floating-Point, v2.05, DFP, dctfix[.] # DFP Convert To Fixed
DCTFIX PPC64LE 111011 frt:5 00000 frb:5 01001000100
DCTFIXd PPC64LE 111011 frt:5 00000 frb:5 01001000101

@ format:X, book:I, page:237, Decimal_Floating-Point, v2.05, DFP, dctfixq[.] # DFP Convert To Fixed Quad
DCTFIXQ PPC64LE 111111 frt:5 00000 frbq:5 01001000100
DCTFIXQd PPC64LE 111111 frt:5 00000 frbq:5 01001000101

@ format:X, book:I, page:237, Decimal_Floating-Point, v3.1, DFP, Skip, dctfixqq # DFP Convert To Fixed Quadword Quad
DCTFIXQQ PPC64LE 111111 a:5 00001 b:5 11111000100

@ format:X, book:I, page:233, Decimal_Floating-Point, v2.05, DFP, dctqpq[.] # DFP Convert To DFP Extended
DCTQPQ PPC64LE 111111 frtp:5 00000 frb:5 01000000100
DCTQPQd PPC64LE 111111 frtp:5 00000 frb:5 01000000101

@ format:X, book:I, page:239, Decimal_Floating-Point, v2.05, DFP, ddedpd[.] # DFP Decode DPD To BCD
DDEDPD PPC64LE 111011 frt:5 sp:2 000 frb:5 01010000100
DDEDPDd PPC64LE 111011 frt:5 sp:2 000 frb:5 01010000101

@ format:X, book:I, page:239, Decimal_Floating-Point, v2.05, DFP, ddedpdq[.] # DFP Decode DPD To BCD Quad
DDEDPDQ PPC64LE 111111 frtp:5 sp:2 000 frbp:5 01010000100
DDEDPDQd PPC64LE 111111 frtp:5 sp:2 000 frbp:5 01010000101

@ format:X, book:I, page:213, Decimal_Floating-Point, v2.05, DFP, ddiv[.] # DFP Divide
DDIV PPC64LE 111011 frt:5 fra:5 frb:5 10001000100
DDIVd PPC64LE 111011 frt:5 fra:5 frb:5 10001000101

@ format:X, book:I, page:213, Decimal_Floating-Point, v2.05, DFP, ddivq[.] # DFP Divide Quad
DDIVQ PPC64LE 111111 frtp:5 frap:5 frbp:5 10001000100
DDIVQd PPC64LE 111111 frtp:5 frap:5 frbp:5 10001000101

@ format:X, book:I, page:239, Decimal_Floating-Point, v2.05, DFP, denbcd[.] # DFP Encode BCD To DPD
DENBCD PPC64LE 111011 frt:5 s:1 0000 frb:5 11010000100
DENBCDd PPC64LE 111011 frt:5 s:1 0000 frb:5 11010000101

@ format:X, book:I, page:239, Decimal_Floating-Point, v2.05, DFP, denbcdq[.] # DFP Encode BCD To DPD Quad
DENBCDQ PPC64LE 111111 frtp:5 s:1 0000 frbp:5 11010000100
DENBCDQd PPC64LE 111111 frtp:5 s:1 0000 frbp:5 11010000101

@ format:X, book:I, page:240, Decimal_Floating-Point, v2.05, DFP, diex[.] # DFP Insert Biased Exponent
DIEX PPC64LE 111011 frt:5 fra:5 frb:5 11011000100
DIEXd PPC64LE 111011 frt:5 fra:5 frb:5 11011000101

@ format:X, book:I, page:240, Decimal_Floating-Point, v2.05, DFP, diexq[.] # DFP Insert Biased Exponent Quad
DIEXQ PPC64LE 111111 frtp:5 fra:5 frbp:5 11011000100
DIEXQd PPC64LE 111111 frtp:5 fra:5 frbp:5 11011000101

@ format:XO, book:I, page:89, Fixed-Point, PPC, SR, PPC64, divd[o][.] # Divide Doubleword
DIVD PPC64LE 011111 rt:5 ra:5 rb:5 01111010010 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVDd PPC64LE 011111 rt:5 ra:5 rb:5 01111010011 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVDo PPC64LE 011111 rt:5 ra:5 rb:5 11111010010 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVDod PPC64LE 011111 rt:5 ra:5 rb:5 11111010011 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:XO, book:I, page:90, Fixed-Point, v2.06, SR, divde[o][.] # Divide Doubleword Extended
DIVDE PPC64LE 011111 rt:5 ra:5 rb:5 01101010010 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVDEd PPC64LE 011111 rt:5 ra:5 rb:5 01101010011 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVDEo PPC64LE 011111 rt:5 ra:5 rb:5 11101010010 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVDEod PPC64LE 011111 rt:5 ra:5 rb:5 11101010011 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:XO, book:I, page:90, Fixed-Point, v2.06, SR, divdeu[o][.] # Divide Doubleword Extended Unsigned
DIVDEU PPC64LE 011111 rt:5 ra:5 rb:5 01100010010 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVDEUd PPC64LE 011111 rt:5 ra:5 rb:5 01100010011 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVDEUo PPC64LE 011111 rt:5 ra:5 rb:5 11100010010 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVDEUod PPC64LE 011111 rt:5 ra:5 rb:5 11100010011 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:XO, book:I, page:89, Fixed-Point, PPC, SR, PPC64, divdu[o][.] # Divide Doubleword Unsigned
DIVDU PPC64LE 011111 rt:5 ra:5 rb:5 01110010010 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVDUd PPC64LE 011111 rt:5 ra:5 rb:5 01110010011 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVDUo PPC64LE 011111 rt:5 ra:5 rb:5 11110010010 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVDUod PPC64LE 011111 rt:5 ra:5 rb:5 11110010011 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:XO, book:I, page:82, Fixed-Point, PPC, SR, divw[o][.] # Divide Word
DIVW PPC64LE 011111 rt:5 ra:5 rb:5 01111010110 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVWd PPC64LE 011111 rt:5 ra:5 rb:5 01111010111 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVWo PPC64LE 011111 rt:5 ra:5 rb:5 11111010110 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVWod PPC64LE 011111 rt:5 ra:5 rb:5 11111010111 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:XO, book:I, page:83, Fixed-Point, v2.06, SR, divwe[o][.] # Divide Word Extended
DIVWE PPC64LE 011111 rt:5 ra:5 rb:5 01101010110 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVWEd PPC64LE 011111 rt:5 ra:5 rb:5 01101010111 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVWEo PPC64LE 011111 rt:5 ra:5 rb:5 11101010110 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVWEod PPC64LE 011111 rt:5 ra:5 rb:5 11101010111 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:XO, book:I, page:83, Fixed-Point, v2.06, SR, divweu[o][.] # Divide Word Extended Unsigned
DIVWEU PPC64LE 011111 rt:5 ra:5 rb:5 01100010110 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVWEUd PPC64LE 011111 rt:5 ra:5 rb:5 01100010111 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVWEUo PPC64LE 011111 rt:5 ra:5 rb:5 11100010110 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVWEUod PPC64LE 011111 rt:5 ra:5 rb:5 11100010111 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:XO, book:I, page:82, Fixed-Point, PPC, SR, divwu[o][.] # Divide Word Unsigned
DIVWU PPC64LE 011111 rt:5 ra:5 rb:5 01110010110 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVWUd PPC64LE 011111 rt:5 ra:5 rb:5 01110010111 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVWUo PPC64LE 011111 rt:5 ra:5 rb:5 11110010110 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
DIVWUod PPC64LE 011111 rt:5 ra:5 rb:5 11110010111 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:X, book:I, page:212, Decimal_Floating-Point, v2.05, DFP, dmul[.] # DFP Multiply
DMUL PPC64LE 111011 frt:5 fra:5 frb:5 00001000100
DMULd PPC64LE 111011 frt:5 fra:5 frb:5 00001000101

@ format:X, book:I, page:212, Decimal_Floating-Point, v2.05, DFP, dmulq[.] # DFP Multiply Quad
DMULQ PPC64LE 111111 frt:5 fra:5 frb:5 00001000100
DMULQd PPC64LE 111111 frt:5 fra:5 frb:5 00001000101

@ format:Z23, book:I, page:223, Decimal_Floating-Point, v2.05, DFP, dqua[.] # DFP Quantize
DQUA PPC64LE 111011 frt:5 fra:5 frb:5 rmc:2 000000110
DQUAd PPC64LE 111011 frt:5 fra:5 frb:5 rmc:2 000000111

@ format:Z23, book:I, page:221, Decimal_Floating-Point, v2.05, DFP, dquai[.] # DFP Quantize Immediate
DQUAI PPC64LE 111011 frt:5 te:5 frb:5 rmc:2 010000110
DQUAId PPC64LE 111011 frt:5 te:5 frb:5 rmc:2 010000111

@ format:Z23, book:I, page:221, Decimal_Floating-Point, v2.05, DFP, dquaiq[.] # DFP Quantize Immediate Quad
DQUAIQ PPC64LE 111111 frtp:5 te:5 frbp:5 rmc:2 010000110
DQUAIQd PPC64LE 111111 frtp:5 te:5 frbp:5 rmc:2 010000111

@ format:Z23, book:I, page:223, Decimal_Floating-Point, v2.05, DFP, dquaq[.] # DFP Quantize Quad
DQUAQ PPC64LE 111111 frtp:5 frap:5 frbp:5 rmc:2 000000110
DQUAQd PPC64LE 111111 frtp:5 frap:5 frbp:5 rmc:2 000000111

@ format:X, book:I, page:234, Decimal_Floating-Point, v2.05, DFP, drdpq[.] # DFP Round To DFP Long
DRDPQ PPC64LE 111111 frtp:5 00000 frbp:5 11000000100
DRDPQd PPC64LE 111111 frtp:5 00000 frbp:5 11000000101

@ format:Z23, book:I, page:230, Decimal_Floating-Point, v2.05, DFP, drintn[.] # DFP Round To FP Integer Without Inexact
DRINTN PPC64LE 111011 frt:5 0000 r:1 frb:5 rmc:2 111000110
DRINTNd PPC64LE 111011 frt:5 0000 r:1 frb:5 rmc:2 111000111

@ format:Z23, book:I, page:230, Decimal_Floating-Point, v2.05, DFP, drintnq[.] # DFP Round To FP Integer Without Inexact Quad
DRINTNQ PPC64LE 111111 frtp:5 0000 r:1 frbp:5 rmc:2 111000110
DRINTNQd PPC64LE 111111 frtp:5 0000 r:1 frbp:5 rmc:2 111000111

@ format:Z23, book:I, page:228, Decimal_Floating-Point, v2.05, DFP, drintx[.] # DFP Round To FP Integer With Inexact
DRINTX PPC64LE 111011 frt:5 0000 r:1 frb:5 rmc:2 011000110
DRINTXd PPC64LE 111011 frt:5 0000 r:1 frb:5 rmc:2 011000111

@ format:Z23, book:I, page:228, Decimal_Floating-Point, v2.05, DFP, drintxq[.] # DFP Round To FP Integer With Inexact Quad
DRINTXQ PPC64LE 111111 frtp:5 0000 r:1 frbp:5 rmc:2 011000110
DRINTXQd PPC64LE 111111 frtp:5 0000 r:1 frbp:5 rmc:2 011000111

@ format:Z23, book:I, page:225, Decimal_Floating-Point, v2.05, DFP, drrnd[.] # DFP Reround
DRRND PPC64LE 111011 frt:5 fra:5 frb:5 rmc:2 001000110
DRRNDd PPC64LE 111011 frt:5 fra:5 frb:5 rmc:2 001000111

@ format:Z23, book:I, page:225, Decimal_Floating-Point, v2.05, DFP, drrndq[.] # DFP Reround Quad
DRRNDQ PPC64LE 111111 frtp:5 fra:5 frbp:5 rmc:2 001000110
DRRNDQd PPC64LE 111111 frtp:5 fra:5 frbp:5 rmc:2 001000111

@ format:X, book:I, page:234, Decimal_Floating-Point, v2.05, DFP, drsp[.] # DFP Round To DFP Short
DRSP PPC64LE 111011 frt:5 00000 frb:5 11000000100
DRSPd PPC64LE 111011 frt:5 00000 frb:5 11000000101

@ format:Z22, book:I, page:242, Decimal_Floating-Point, v2.05, DFP, dscli[.] # DFP Shift Significand Left Immediate
DSCLI PPC64LE 111011 frt:5 fra:5 sh:6 0010000100
DSCLId PPC64LE 111011 frt:5 fra:5 sh:6 0010000101

@ format:Z22, book:I, page:242, Decimal_Floating-Point, v2.05, DFP, dscliq[.] # DFP Shift Significand Left Immediate Quad
DSCLIQ PPC64LE 111111 frtp:5 frap:5 sh:6 0010000100
DSCLIQd PPC64LE 111111 frtp:5 frap:5 sh:6 0010000101

@ format:Z22, book:I, page:242, Decimal_Floating-Point, v2.05, DFP, dscri[.] # DFP Shift Significand Right Immediate
DSCRI PPC64LE 111011 frt:5 fra:5 sh:6 0011000100
DSCRId PPC64LE 111011 frt:5 fra:5 sh:6 0011000101

@ format:Z22, book:I, page:242, Decimal_Floating-Point, v2.05, DFP, dscriq[.] # DFP Shift Significand Right Immediate Quad
DSCRIQ PPC64LE 111111 frtp:5 frap:5 sh:6 0011000100
DSCRIQd PPC64LE 111111 frtp:5 frap:5 sh:6 0011000101

@ format:X, book:I, page:210, Decimal_Floating-Point, v2.05, DFP, dsub[.] # DFP Subtract
DSUB PPC64LE 111011 frt:5 fra:5 frb:5 10000000100
DSUBd PPC64LE 111011 frt:5 fra:5 frb:5 10000000101

@ format:X, book:I, page:210, Decimal_Floating-Point, v2.05, DFP, dsubq[.] # DFP Subtract Quad
DSUBQ PPC64LE 111111 frtp:5 frap:5 frbp:5 10000000100
DSUBQd PPC64LE 111111 frtp:5 frap:5 frbp:5 10000000101

@ format:Z22, book:I, page:217, Decimal_Floating-Point, v2.05, DFP, dtstdc # DFP Test Data Class
DTSTDC PPC64LE 111011 bf:3 00 fra:5 dcm:6 0110000100

@ format:Z22, book:I, page:217, Decimal_Floating-Point, v2.05, DFP, dtstdcq # DFP Test Data Class Quad
DTSTDCQ PPC64LE 111111 bf:3 00 frap:5 dcm:6 0110000100

@ format:Z22, book:I, page:217, Decimal_Floating-Point, v2.05, DFP, dtstdg # DFP Test Data Group
DTSTDG PPC64LE 111011 bf:3 00 frap:5 dgm:6 0111000100

@ format:Z22, book:I, page:217, Decimal_Floating-Point, v2.05, DFP, dtstdgq # DFP Test Data Group Quad
DTSTDGQ PPC64LE 111111 bf:3 00 frap:5 dgm:6 0111000100

@ format:X, book:I, page:218, Decimal_Floating-Point, v2.05, DFP, dtstex # DFP Test Exponent
DTSTEX PPC64LE 111011 bf:3 00 fra:5 frb:5 00101000100

@ format:X, book:I, page:218, Decimal_Floating-Point, v2.05, DFP, dtstexq # DFP Test Exponent Quad
DTSTEXQ PPC64LE 111111 bf:3 00 frap:5 frbp:5 00101000100

@ format:X, book:I, page:219, Decimal_Floating-Point, v2.05, DFP, dtstsf # DFP Test Significance
DTSTSF PPC64LE 111011 bf:3 00 fra:5 frb:5 10101000100

@ format:X, book:I, page:220, Decimal_Floating-Point, v3.0, DFP, dtstsfi # DFP Test Significance Immediate
DTSTSFI PPC64LE 111011 bf:3 0 uim:6 frb:5 10101000110

@ format:X, book:I, page:220, Decimal_Floating-Point, v3.0, DFP, dtstsfiq # DFP Test Significance Immediate Quad
DTSTSFIQ PPC64LE 111111 bf:3 0 uim:6 frbp:5 10101000110

@ format:X, book:I, page:219, Decimal_Floating-Point, v2.05, DFP, dtstsfq # DFP Test Significance Quad
DTSTSFQ PPC64LE 111111 bf:3 00 fra:5 frb:5 10101000100

@ format:X, book:I, page:240, Decimal_Floating-Point, v2.05, DFP, dxex[.] # DFP Extract Biased Exponent
DXEX PPC64LE 111011 frt:5 00000 frb:5 01011000100
DXEXd PPC64LE 111011 frt:5 00000 frb:5 01011000101

@ format:X, book:I, page:240, Decimal_Floating-Point, v2.05, DFP, dxexq[.] # DFP Extract Biased Exponent Quad
DEXEQ PPC64LE 111111 frt:5 00000 frbp:5 01011000100
DEXEQd PPC64LE 111111 frt:5 00000 frbp:5 01011000101

@ format:X, book:II, page:1098, Storage_Control, PPC, Skip, eieio # Enforce In-order Execution of I/O
EIEIO PPC64LE 01111100000000000000011010101100

@ format:X, book:I, page:101, Fixed-Point, P1, SR, eqv[.] # Equivalent
EQV PPC64LE 011111 rs:5 ra:5 rb:5 01000111000 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }
EQVd PPC64LE 011111 rs:5 ra:5 rb:5 01000111001 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }

@ format:X, book:I, page:102, Fixed-Point, PPC, SR, extsb[.] # Extend Sign Byte
EXTSB PPC64LE 011111 rs:5 ra:5 0000011101110100 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }
EXTSBd PPC64LE 011111 rs:5 ra:5 0000011101110101 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:X, book:I, page:102, Fixed-Point, P1, SR, extsh[.] # Extend Sign Halfword
EXTSH PPC64LE 011111 rs:5 ra:5 0000011100110100 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }
EXTSHd PPC64LE 011111 rs:5 ra:5 0000011100110101 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:X, book:I, page:104, Fixed-Point, PPC, SR, PPC64, extsw[.] # Extend Sign Word
EXTSW PPC64LE 011111 rs:5 ra:5 0000011110110100 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }
EXTSWd PPC64LE 011111 rs:5 ra:5 0000011110110101 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:XS, book:I, page:116, Fixed-Point, v3.0, extswsli[.] # Extend Sign Word and Shift Left Immediate
EXTSWSLI PPC64LE 011111 rs:5 ra:5 sha:5 110111101 shb:1 0 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }
EXTSWSLId PPC64LE 011111 rs:5 ra:5 sha:5 110111101 shb:1 1 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:X, book:I, page:165, Floating-Point, P1, fabs[.] # Floating Absolute Value
FABS PPC64LE 111111 frt:5 00000 frb:5 01000010000
FABSd PPC64LE 111111 frt:5 00000 frb:5 01000010001

@ format:A, book:I, page:167, Floating-Point, P1, fadd[.] # Floating Add
FADD PPC64LE 111111 frt:5 fra:5 frb:5 00000101010
FADDd PPC64LE 111111 frt:5 fra:5 frb:5 00000101011

@ format:A, book:I, page:167, Floating-Point, PPC, fadds[.] # Floating Add Single
FADDS PPC64LE 111011 frt:5 fra:5 frb:5 00000101010
FADDSd PPC64LE 111011 frt:5 fra:5 frb:5 00000101011

@ format:X, book:I, page:178, Floating-Point, PPC, PPC64, fcfid[.] # Floating Convert with round Signed Doubleword to Double-Precision format
FCFID PPC64LE 111111 frt:5 00000 frb:5 11010011100
FCFIDd PPC64LE 111111 frt:5 00000 frb:5 11010011101

@ format:X, book:I, page:179, Floating-Point, v2.06, fcfids[.] # Floating Convert with round Signed Doubleword to Single-Precision format
FCFIDS PPC64LE 111011 frt:5 00000 frb:5 11010011100
FCFIDSd PPC64LE 111011 frt:5 00000 frb:5 11010011101

@ format:X, book:I, page:179, Floating-Point, v2.06, fcfidu[.] # Floating Convert with round Unsigned Doubleword to Double-Precision format
FCFIDU PPC64LE 111111 frt:5 00000 frb:5 11110 011100
FCFIDUd PPC64LE 111111 frt:5 00000 frb:5 11110 011101

@ format:X, book:I, page:180, Floating-Point, v2.06, fcfidus[.] # Floating Convert with round Unsigned Doubleword to Single-Precision format
FCFIDUS PPC64LE 111011 frt:5 00000 frb:5 11110011100
FCFIDUSd PPC64LE 111011 frt:5 00000 frb:5 11110011101

@ format:X, book:I, page:183, Floating-Point, P1, fcmpo # Floating Compare Ordered
FCMPO PPC64LE 111111 bf:3 00 fra:5 frb:5 00001000000

@ format:X, book:I, page:183, Floating-Point, P1, fcmpu # Floating Compare Unordered
FCMPU PPC64LE 111111 bf:3 00 fra:5 frb:5 00000000000

@ format:X, book:I, page:165, Floating-Point, v2.05, fcpsgn[.] # Floating Copy Sign
FCPSGN PPC64LE 111111 frt:5 fra:5 frb:5 00000010000
FCPSGNd PPC64LE 111111 frt:5 fra:5 frb:5 00000010001

@ format:X, book:I, page:174, Floating-Point, PPC, PPC64, fctid[.] # Floating Convert with round Double-Precision To Signed Doubleword format
FCTID PPC64LE 111111 frt:5 00000 frb:5 11001011100
FCTIDd PPC64LE 111111 frt:5 00000 frb:5 11001011101

@ format:X, book:I, page:175, Floating-Point, v2.06, fctidu[.] # Floating Convert with round Double-Precision To Unsigned Doubleword format
FCTIDU PPC64LE 111111 frt:5 00000 frb:5 11101011100
FCTIDUd PPC64LE 111111 frt:5 00000 frb:5 11101011101

@ format:X, book:I, page:176, Floating-Point, v2.06, fctiduz[.] # Floating Convert with truncate Double-Precision To Unsigned Doubleword format
FCTIDUZ PPC64LE 111111 frt:5 00000 frb:5 11101011110
FCTIDUZd PPC64LE 111111 frt:5 00000 frb:5 11101011111

@ format:X, book:I, page:175, Floating-Point, PPC, PPC64, fctidz[.] # Floating Convert with truncate Double-Precision To Signed Doubleword format
FCTIDZ PPC64LE 111111 frt:5 00000 frb:5 11001011110
FCTIDZd PPC64LE 111111 frt:5 00000 frb:5 11001011111

@ format:X, book:I, page:176, Floating-Point, P2, fctiw[.] # Floating Convert with round Double-Precision To Signed Word format
FCTIW PPC64LE 111111 frt:5 00000 frb:5 00000011100
FCTIWd PPC64LE 111111 frt:5 00000 frb:5 00000011101

@ format:X, book:I, page:177, Floating-Point, v2.06, fctiwu[.] # Floating Convert with round Double-Precision To Unsigned Word format
FCTIWU PPC64LE 111111 frt:5 00000 frb:5 00100011100
FCTIWUd PPC64LE 111111 frt:5 00000 frb:5 00100011101

@ format:X, book:I, page:176, Floating-Point, v2.06, fctiwuz[.] # Floating Convert with truncate Double-Precision To Unsigned Word format
FCTIWUZ PPC64LE 111111 frt:5 00000 frb:5 00100011110
FCTIWUZd PPC64LE 111111 frt:5 00000 frb:5 00100011111

@ format:X, book:I, page:177, Floating-Point, P2, fctiwz[.] # Floating Convert with truncate Double-Precision To Signed Word fomat
FCTIWZ PPC64LE 111111 frt:5 00000 frb:5 00000011110
FCTIWZd PPC64LE 111111 frt:5 00000 frb:5 00000011111

@ format:A, book:I, page:168, Floating-Point, P1, fdiv[.] # Floating Divide
FDIV PPC64LE 111111 frt:5 fra:5 frb:5 00000100100
FDIVd PPC64LE 111111 frt:5 fra:5 frb:5 00000100101

@ format:A, book:I, page:168, Floating-Point, PPC, fdivs[.] # Floating Divide Single
FDIVS PPC64LE 111011 frt:5 fra:5 frb:5 00000100100
FDIVSd PPC64LE 111011 frt:5 fra:5 frb:5 00000100101

@ format:A, book:I, page:172, Floating-Point, P1, fmadd[.] # Floating Multiply-Add
FMADD PPC64LE 111111 frt:5 fra:5 frb:5 frc:5 111010
FMADDd PPC64LE 111111 frt:5 fra:5 frb:5 frc:5 111011

@ format:A, book:I, page:172, Floating-Point, PPC, fmadds[.] # Floating Multiply-Add Single
FMADDS PPC64LE 111011 frt:5 fra:5 frb:5 frc:5 111010
FMADDSd PPC64LE 111011 frt:5 fra:5 frb:5 frc:5 111011

@ format:X, book:I, page:165, Floating-Point, P1, fmr[.] # Floating Move Register
FMR PPC64LE 111111 frt:5 00000 frb:5 00010010000
FMRd PPC64LE 111111 frt:5 00000 frb:5 00010010001

@ format:X, book:I, page:166, Floating-Point, v2.07, fmrgew # Floating Merge Even Word
FMRGEW PPC64LE 111111 frt:5 fra:5 frb:5 11110001100

@ format:X, book:I, page:166, Floating-Point, v2.07, fmrgow # Floating Merge Odd Word
FMRGOW PPC64LE 111111 frt:5 fra:5 frb:5 11010001100

@ format:A, book:I, page:172, Floating-Point, P1, fmsub[.] # Floating Multiply-Subtract
FMSUB PPC64LE 111111 frt:5 fra:5 frb:5 frc:5 111000
FMSUBd PPC64LE 111111 frt:5 fra:5 frb:5 frc:5 111001

@ format:A, book:I, page:172, Floating-Point, PPC, fmsubs[.] # Floating Multiply-Subtract Single
FMSUBS PPC64LE 111011 frt:5 fra:5 frb:5 frc:5 111000
FMSUBSd PPC64LE 111011 frt:5 fra:5 frb:5 frc:5 111001

@ format:A, book:I, page:168, Floating-Point, P1, fmul[.] # Floating Multiply
FMUL PPC64LE 111111 frt:5 fra:5 00000 frb:5 110010
FMULd PPC64LE 111111 frt:5 fra:5 00000 frb:5 110011

@ format:A, book:I, page:168, Floating-Point, PPC, fmuls[.] # Floating Multiply Single
FMULS PPC64LE 111011 frt:5 fra:5 00000 frb:5 110010
FMULSd PPC64LE 111011 frt:5 fra:5 00000 frb:5 110011

@ format:X, book:I, page:165, Floating-Point, P1, fnabs[.] # Floating Negative Absolute Value
FNABS PPC64LE 111111 frt:5 00000 frb:5 00100010000
FNABSd PPC64LE 111111 frt:5 00000 frb:5 00100010001

@ format:X, book:I, page:165, Floating-Point, P1, fneg[.] # Floating Negate
FNEG PPC64LE 111111 frt:5 00000 frb:5 00001010000
FNEGd PPC64LE 111111 frt:5 00000 frb:5 00001010001

@ format:A, book:I, page:173, Floating-Point, P1, fnmadd[.] # Floating Negative Multiply-Add
FNMADD PPC64LE 111111 frt:5 fra:5 frb:5 frc:5 111110
FNMADDd PPC64LE 111111 frt:5 fra:5 frb:5 frc:5 111111

@ format:A, book:I, page:173, Floating-Point, PPC, fnmadds[.] # Floating Negative Multiply-Add Single
FNMADDS PPC64LE 111011 frt:5 fra:5 frb:5 frc:5 111110
FNMADDSd PPC64LE 111011 frt:5 fra:5 frb:5 frc:5 111111

@ format:A, book:I, page:173, Floating-Point, P1, fnmsub[.] # Floating Negative Multiply-Subtract
FNMSUB PPC64LE 111111 frt:5 fra:5 frb:5 frc:5 111100
FNMSUBd PPC64LE 111111 frt:5 fra:5 frb:5 frc:5 111101

@ format:A, book:I, page:173, Floating-Point, PPC, fnmsubs[.] # Floating Negative Multiply-Subtract Single
FNMSUBS PPC64LE 111011 frt:5 fra:5 frb:5 frc:5 111100
FNMSUBSd PPC64LE 111011 frt:5 fra:5 frb:5 frc:5 111101

@ format:A, book:I, page:169, Floating-Point, v2.02, fre[.] # Floating Reciprocal Estimate
FRE PPC64LE 111111 frt:5 00000 frb:5 00000110000
FREd PPC64LE 111111 frt:5 00000 frb:5 00000110001

@ format:A, book:I, page:169, Floating-Point, PPC, fres[.] # Floating Reciprocal Estimate Single
FRES PPC64LE 111011 frt:5 00000 frb:5 00000110000
FRESd PPC64LE 111011 frt:5 00000 frb:5 00000110001

@ format:X, book:I, page:182, Floating-Point, v2.02, frim[.] # Floating Round to Integer Minus
FRIM PPC64LE 111111 frt:5 00000 frb:5 01111 010000
FRIMd PPC64LE 111111 frt:5 00000 frb:5 01111 010001

@ format:X, book:I, page:182, Floating-Point, v2.02, frin[.] # Floating Round to Integer Nearest
FRIN PPC64LE 111111 frt:5 00000 frb:5 01100 010000
FRINd PPC64LE 111111 frt:5 00000 frb:5 01100 010001

@ format:X, book:I, page:182, Floating-Point, v2.02, frip[.] # Floating Round to Integer Plus
FRIP PPC64LE 111111 frt:5 00000 frb:5 01110 010000
FRIPd PPC64LE 111111 frt:5 00000 frb:5 01110 010001

@ format:X, book:I, page:182, Floating-Point, v2.02, friz[.] # Floating Round to Integer Toward Zero
FRIZ PPC64LE 111111 frt:5 00000 frb:5 01101 010000
FRIZd PPC64LE 111111 frt:5 00000 frb:5 01101 010001

@ format:X, book:I, page:174, Floating-Point, P1, frsp[.] # Floating Round to Single-Precision
FRSP PPC64LE 111111 frt:5 00000 frb:5 00000011000
FRSPd PPC64LE 111111 frt:5 00000 frb:5 00000011001

@ format:A, book:I, page:170, Floating-Point, PPC, frsqrte[.] # Floating Reciprocal Square Root Estimate
FRSQRTE PPC64LE 111111 frt:5 00000 frb:5 00000110100
FRSQRTEd PPC64LE 111111 frt:5 00000 frb:5 00000110101

@ format:A, book:I, page:170, Floating-Point, v2.02, frsqrtes[.] # Floating Reciprocal Square Root Estimate Single
FRSQRTES PPC64LE 111011 frt:5 00000 frb:5 00000110100
FRSQRTESd PPC64LE 111011 frt:5 00000 frb:5 00000110101

@ format:A, book:I, page:184, Floating-Point, PPC, fsel[.] # Floating Select
FSEL PPC64LE 111111 frt:5 fra:5 frb:5 frc:5 101110
FSELd PPC64LE 111111 frt:5 fra:5 frb:5 frc:5 101111

@ format:A, book:I, page:169, Floating-Point, P2, Optional, fsqrt[.] # Floating Square Root
FSQRT PPC64LE 111111 frt:5 00000 frb:5 00000101100
FSQRTd PPC64LE 111111 frt:5 00000 frb:5 00000101101

@ format:A, book:I, page:169, Floating-Point, PPC, Optional, fsqrts[.] # Floating Square Root Single
FSQRTS PPC64LE 111011 frt:5 00000 frb:5 00000101100
FSQRTSd PPC64LE 111011 frt:5 00000 frb:5 00000101101

@ format:A, book:I, page:167, Floating-Point, P1, fsub[.] # Floating Subtract
FSUB PPC64LE 111111 frt:5 fra:5 frb:5 00000101000
FSUBd PPC64LE 111111 frt:5 fra:5 frb:5 00000101001

@ format:A, book:I, page:167, Floating-Point, PPC, fsubs[.] # Floating Subtract Single
FSUBS PPC64LE 111011 frt:5 fra:5 frb:5 00000101000
FSUBSd PPC64LE 111011 frt:5 fra:5 frb:5 00000101001

@ format:X, book:I, page:170, Floating-Point, v2.06, ftdiv # Floating Test for software Divide
FTDIV PPC64LE 111111 bf:3 00 fra:5 frb:5 00100000000

@ format:X, book:I, page:171, Floating-Point, v2.06, ftsqrt # Floating Test for software Square Root
FTSQRT PPC64LE 111111 bf:3 0000000 frb:5 00101000000

@ format:X, book:I, page:121, Fixed-Point, v3.1B, Skip, hashchk # Hash Check
HASHCHK PPC64LE 011111 a:15 1011110010 rc:1

@ format:X, book:III, page:1175, Fixed-Point, v3.1B, P, Skip, hashchkp # Hash Check Privileged
HASHCHKP PPC64LE 011111 a:15 1010110010 rc:1

@ format:X, book:I, page:121, Fixed-Point, v3.1B, Skip, hashst # Hash Store
HASHST PPC64LE 011111 a:15 1011010010 rc:1

@ format:X, book:III, page:1175, Fixed-Point, v3.1B, P, Skip, hashstp # Hash Store Privileged
HASHSTP PPC64LE 011111 a:15 1010010010 rc:1

@ format:XL, book:III, page:1162, Branch, v2.02, HV, Skip, hrfid # Return From Interrupt Doubleword Hypervisor
HRFID PPC64LE 01001100000000000000001000100100

@ format:X, book:II, page:1062, Storage_Control, PPC, Skip, icbi # Instruction Cache Block Invalidate
ICBI PPC64LE 01111100000 a:10 11110101100

@ format:X, book:II, page:1062, Storage_Control, v2.07, Skip, icbt # Instruction Cache Block Touch
ICBT PPC64LE 0111110 a:14 00000101100

@ format:A, book:I, page:98, Fixed-Point, v2.03, isel # Integer Select
ISEL PPC64LE 011111 rt:5 ra:5 rb:5 bc:5 011110 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:XL, book:II, page:1086, Storage_Control, P1, Skip, isync # Instruction Synchronize
ISYNC PPC64LE 01001100000000000000000100101100

@ format:X, book:II, page:1087, Storage_Control, v2.06, Skip, lbarx # Load Byte And Reserve Indexed
LBARX PPC64LE 011111 a:15 0000110100 rc:1

@ format:D, book:I, page:52, Fixed-Point, P1, lbz # Load Byte and Zero
LBZ PPC64LE 100010 rt:5 ra:5 imm:16 \
!constraints { $rt != 1 && $ra > 1 && $rt != 13 && $ra != 13 && $ra != $rt && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:X, book:III, page:1174, Fixed-Point, v2.05, HV, Skip, lbzcix # Load Byte & Zero Caching Inhibited Indexed
LBZCIX PPC64LE 011111 a:15 11010101010

@ format:D, book:I, page:52, Fixed-Point, P1, lbzu # Load Byte and Zero with Update
LBZU PPC64LE 100011 rt:5 ra:5 imm:16 \
!constraints { $rt != 1 && $ra > 1 && $rt != 13 && $ra != 13 && $ra != $rt && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:X, book:I, page:52, Fixed-Point, P1, lbzux # Load Byte and Zero with Update Indexed
LBZUX PPC64LE 011111 rt:5 ra:5 rb:5 00011101110 \
!constraints { $rt != 1 && $ra > 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13 && $ra != $rt && $ra != $rb && $rt != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:52, Fixed-Point, P1, lbzx # Load Byte and Zero Indexed
LBZX PPC64LE 011111 rt:5 ra:5 rb:5 00010101110 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13 && $ra != $rt && $ra != $rb && $rt != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:DS, book:I, page:57, Fixed-Point, PPC, PPC64, ld # Load Doubleword
LD PPC64LE 111010 rt:5 ra:5 imm:14 00 \
!constraints { $rt != 1 && $ra > 1 && $rt != 13 && $ra != 13 && $ra != $rt && $imm <= 8176; } \
!memory { reg_plus_imm($ra, $imm << 2); }

@ format:X, book:II, page:1092, Storage_Control, PPC, Skip, ldarx # Load Doubleword And Reserve Indexed
LDARX PPC64LE 011111 a:15 00010101000

@ format:X, book:II, page:1083, Storage_Control, v3.0, AMO, Skip, ldat # Load Doubleword ATomic
LDAT PPC64LE 011111 a:15 10011001100

@ format:X, book:I, page:69, Fixed-Point, v2.06, ldbrx # Load Doubleword Byte-Reverse Indexed
LDBRX PPC64LE 011111 rt:5 ra:5 rb:5 10000101000 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13 && $ra != $rt && $ra != $rb && $rt != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:III, page:1174, Fixed-Point, v2.05, HV, Skip, ldcix # Load Doubleword Caching Inhibited Indexed
LDCIX PPC64LE 011111 a:15 11011101010

@ format:DS, book:I, page:57, Fixed-Point, PPC, PPC64, ldu # Load Doubleword with Update
LDU PPC64LE 111010 rt:5 ra:5 imm:14 01 \
!constraints { $rt != 1 && $ra > 1 && $rt != 13 && $ra != 13 && $ra != $rt && $imm <= 8176; } \
!memory { reg_plus_imm($ra, $imm << 2); }

@ format:X, book:I, page:57, Fixed-Point, PPC, PPC64, ldux # Load Doubleword with Update Indexed
LDUX PPC64LE 011111 rt:5 ra:5 rb:5 00001101010 \
!constraints { $rt != 1 && $ra > 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13 && $ra != $rt && $ra != $rb && $rt != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:57, Fixed-Point, PPC, PPC64, ldx # Load Doubleword Indexed
LDX PPC64LE 011111 rt:5 ra:5 rb:5 00000101010 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13 && $ra != $rt && $ra != $rb && $rt != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:D, book:I, page:156, Floating-Point, P1, lfd # Load Floating-Point Double
LFD PPC64LE 110010 frt:5 ra:5 imm:16 \
!constraints { $ra > 1 && $ra != 13 && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:DS, book:I, page:163, Floating-Point, v2.05, lfdp # Load Floating-Point Double Pair
LFDP PPC64LE 111001 frtp:5 ra:5 imm:14 00 \
!constraints { $frtp % 2 == 0 && $ra > 1 && $ra != 13 && $imm <= 8176; } \
!memory { reg_plus_imm($ra, $imm << 2); }

@ format:X, book:I, page:163, Floating-Point, v2.05, lfdpx # Load Floating-Point Double Pair Indexed
LFDPX PPC64LE 011111 frtp:5 ra:5 rb:5 11000101110 \
!constraints { $frtp % 2 == 0 && $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:D, book:I, page:156, Floating-Point, P1, lfdu # Load Floating-Point Double with Update
LFDU PPC64LE 110011 frt:5 ra:5 imm:16 \
!constraints { $ra > 1 && $ra != 13 && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:X, book:I, page:156, Floating-Point, P1, lfdux # Load Floating-Point Double with Update Indexed
LFDUX PPC64LE 011111 frt:5 ra:5 rb:5 10011101110 \
!constraints { $ra > 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:156, Floating-Point, P1, lfdx # Load Floating-Point Double Indexed
LFDX PPC64LE 011111 frt:5 ra:5 rb:5 10010101110 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:157, Floating-Point, v2.05, lfiwax # Load Floating-Point as Integer Word Algebraic Indexed
LFIWAX PPC64LE 011111 frt:5 ra:5 rb:5 11010101110 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:157, Floating-Point, v2.06, lfiwzx # Load Floating-Point as Integer Word & Zero Indexed
LFIWZX PPC64LE 011111 frt:5 ra:5 rb:5 11011101110 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:D, book:I, page:154, Floating-Point, P1, lfs # Load Floating-Point Single
LFS PPC64LE 110000 frt:5 ra:5 imm:16 \
!constraints { $ra > 1 && $ra != 13 && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:D, book:I, page:154, Floating-Point, P1, lfsu # Load Floating-Point Single with Update
LFSU PPC64LE 110001 frt:5 ra:5 imm:16 \
!constraints { $ra > 1 && $ra != 13 && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:X, book:I, page:155, Floating-Point, P1, lfsux # Load Floating-Point Single with Update Indexed
LFSUX PPC64LE 011111 frt:5 ra:5 rb:5 10001101110 \
!constraints { $ra > 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:154, Floating-Point, P1, lfsx # Load Floating-Point Single Indexed
LFSX PPC64LE 011111 frt:5 ra:5 rb:5 10000101110 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:D, book:I, page:54, Fixed-Point, P1, lha # Load Halfword Algebraic
LHA PPC64LE 101010 rt:5 ra:5 imm:16 \
!constraints { $rt != 1 && $ra > 1 && $rt != 13 && $ra != 13 && $ra != $rt && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:X, book:II, page:1088, Storage_Control, v2.06, Skip, lharx # Load Halfword And Reserve Indexed
LHARX PPC64LE 011111 a:15 0001110100 rc:1

@ format:D, book:I, page:54, Fixed-Point, P1, lhau # Load Halfword Algebraic with Update
LHAU PPC64LE 101011 rt:5 ra:5 imm:16 \
!constraints { $rt != 1 && $ra > 1 && $rt != 13 && $ra != 13 && $ra != $rt && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:X, book:I, page:54, Fixed-Point, P1, lhaux # Load Halfword Algebraic with Update Indexed
LHAUX PPC64LE 011111 rt:5 ra:5 rb:5 01011101110 \
!constraints { $rt != 1 && $ra > 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13 && $ra != $rt && $ra != $rb && $rt != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:54, Fixed-Point, P1, lhax # Load Halfword Algebraic Indexed
LHAX PPC64LE 011111 rt:5 ra:5 rb:5 01010101110 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13 && $ra != $rt && $ra != $rb && $rt != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:67, Fixed-Point, P1, lhbrx # Load Halfword Byte-Reverse Indexed
LHBRX PPC64LE 011111 rt:5 ra:5 rb:5 11000101100 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13 && $ra != $rt && $ra != $rb && $rt != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:D, book:I, page:53, Fixed-Point, P1, lhz # Load Halfword and Zero
LHZ PPC64LE 101000 rt:5 ra:5 imm:16 \
!constraints { $rt != 1 && $ra > 1 && $rt != 13 && $ra != 13 && $ra != $rt && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:X, book:III, page:1174, Fixed-Point, v2.05, HV, Skip, lhzcix # Load Halfword & Zero Caching Inhibited Indexed
LHZCIX PPC64LE 011111 a:15 11001101010

@ format:D, book:I, page:53, Fixed-Point, P1, lhzu # Load Halfword and Zero with Update
LHZU PPC64LE 101001 rt:5 ra:5 imm:16 \
!constraints { $rt != 1 && $ra > 1 && $rt != 13 && $ra != 13 && $ra != $rt && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:X, book:I, page:53, Fixed-Point, P1, lhzux # Load Halfword and Zero with Update Indexed
LHZUX PPC64LE 011111 rt:5 ra:5 rb:5 01001101110 \
!constraints { $rt != 1 && $ra > 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13 && $ra != $rt && $ra != $rb && $rt != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:53, Fixed-Point, P1, lhzx # Load Halfword and Zero Indexed
LHZX PPC64LE 011111 rt:5 ra:5 rb:5 01000101110 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13 && $ra != $rt && $ra != $rb && $rt != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

# LMW is not supported in little-endian mode
@ format:D, book:I, page:70, Fixed-Point, P1, lmw # Load Multiple Word
LMW PPC64BE 101110 rt:5 ra:5 imm:16 \
!constraints { $rt > 13 && $ra > 1 && $ra != 13 && $imm <= 32752; } \
!memory { \
    my $nr = 32 - $rt; \
    my $regs = (1<<$nr) - 1; \
    set_num("makezero", $regs & (1<<(31-$ra))); \
    reg_plus_imm($ra, $imm); \
}

@ format:DQ, book:I, page:65, Fixed-Point, v2.03, lq # Load Quadword
LQ PPC64LE 111000 rtp:5 ra:5 imm:12 0000 \
!constraints { $rtp % 2 == 0 && $rtp != 0 && $rtp != 12 && $ra > 1 && $ra != 13 && $ra != $rtp && $imm <= 2032; } \
!memory { reg_plus_imm($ra, ($imm << 4) + 8); }

@ format:X, book:I, page:1094, Storage_Control, v2.07, Skip, lqarx # Load Quadword And Reserve Indexed
LQARX PPC64LE 011111 a:15 0100010100 rc:1

@ format:X, book:I, page:72, Fixed-Point, P1, lswi # Load String Word Immediate
LSWI PPC64LE 011111 rt:5 ra:5 rb:5 10010101010 \
!constraints { \
    my $nb = $rb + ($rb ? 0 : 32); \
    my $regs = regs_wrapped($rt, $nb); \
    $ra > 1 && $ra != 13 && ($regs & ((1<<(31-1)) | (1<<(31-13)))) == 0; \
} \
!memory { \
    set_num("makezero", get_num("regs") & (1<<(31-$ra))); \
    reg($ra); \
}

@ format:X, book:I, page:72, Fixed-Point, P1, lswx # Load String Word Indexed
LSWX PPC64LE 011111 rt:5 ra:5 rb:5 10000101010 \
!constraints { \
    my $nb = irand(0x7f); \
    set_num("nb", $nb); \
    my $regs = regs_wrapped($rt, $nb); \
    $ra != 1 && $ra != 13 && $rb != 1 && $rb != 13 && $ra != $rb && ($regs & ((1<<(31-1)) | (1<<(31-13)))) == 0; \
} \
!memory { \
    write_mov_ri($ra, get_num("nb")); \
    insn32((31 << 26) | ($ra << 21) | ((1 & 31) << 16) | ((1 >> 5) << 11) | (467 << 1)); \
    if ($ra) { \
        set_num("makezero", get_num("regs") & (1<<(31-$ra))); \
    } else { \
        set_num("makezero", get_num("regs") & (1<<(31-$rb))); \
    } \
    reg_plus_reg($ra, $rb); \
}

# TODO remaining bytes of vrt are set to undefined values - cannot compare
@ format:X, book:I, page:273, Vector, v2.03, AltiVec, Skip, lvebx # Load Vector Element Byte Indexed
LVEBX PPC64LE 011111 vrt:5 ra:5 rb:5 00000001110 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

# TODO remaining bytes of vrt are set to undefined values - cannot compare
@ format:X, book:I, page:274, Vector, v2.03, AltiVec, Skip, lvehx # Load Vector Element Halfword Indexed
LVEHX PPC64LE 011111 vrt:5 ra:5 rb:5 00001001110 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

# TODO remaining bytes of vrt are set to undefined values - cannot compare
@ format:X, book:I, page:275, Vector, v2.03, AltiVec, Skip, lvewx # Load Vector Element Word Indexed
LVEWX PPC64LE 011111 vrt:5 ra:5 rb:5 00010001110 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:282, Vector, v2.03, AltiVec, lvsl # Load Vector for Shift Left Indexed
LVSL PPC64LE 011111 vrt:5 ra:5 rb:5 00000001100 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:282, Vector, v2.03, AltiVec, lvsr # Load Vector for Shift Right Indexed
LVSR PPC64LE 011111 vrt:5 ra:5 rb:5 00001001100 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:276, Vector, v2.03, AltiVec, lvx # Load Vector Indexed
LVX PPC64LE 011111 vrt:5 ra:5 rb:5 00011001110 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:276, Vector, v2.03, AltiVec, lvxl # Load Vector Indexed Last
LVXL PPC64LE 011111 vrt:5 ra:5 rb:5 01011001110 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:DS, book:I, page:56, Fixed-Point, PPC, PPC64, lwa # Load Word Algebraic
LWA PPC64LE 111010 rt:5 ra:5 imm:14 10 \
!constraints { $rt != 1 && $ra > 1 && $rt != 13 && $ra != 13 && $imm <= 8176; } \
!memory { reg_plus_imm($ra, $imm << 2); }

@ format:X, book:II, page:1088, Storage_Control, PPC, Skip, lwarx # Load Word & Reserve Indexed
LWARX PPC64LE 011111 a:15 00000101000

@ format:X, book:II, page:1083, Storage_Control, v3.0, AMO, Skip, lwat # Load Word ATomic
LWAT PPC64LE 011111 a:15 10010001100

@ format:X, book:I, page:56, Fixed-Point, PPC, PPC64, lwaux # Load Word Algebraic with Update Indexed
LWAUX PPC64LE 011111 rt:5 ra:5 rb:5 01011101010 \
!constraints { $rt != 1 && $ra > 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13 && $ra != $rt && $ra != $rb && $rt != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:56, Fixed-Point, PPC, PPC64, lwax # Load Word Algebraic Indexed
LWAX PPC64LE 011111 rt:5 ra:5 rb:5 01010101010 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13 && $ra != $rt && $ra != $rb && $rt != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:68, Fixed-Point, P1, lwbrx # Load Word Byte-Reverse Indexed
LWBRX PPC64LE 011111 rt:5 ra:5 rb:5 10000101100 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13 && $ra != $rt && $ra != $rb && $rt != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:D, book:I, page:55, Fixed-Point, P1, lwz # Load Word and Zero
LWZ PPC64LE 100000 rt:5 ra:5 imm:16 \
!constraints { $rt != 1 && $ra > 1 && $rt != 13 && $ra != 13 && $ra != $rt && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:X, book:III, page:1174, Fixed-Point, v2.05, HV, Skip, lwzcix # Load Word & Zero Caching Inhibited Indexed
LWZCIX PPC64LE 011111 a:15 11000101010

@ format:D, book:I, page:55, Fixed-Point, P1, lwzu # Load Word and Zero with Update
LWZU PPC64LE 100001 rt:5 ra:5 imm:16 \
!constraints { $rt != 1 && $ra > 1 && $rt != 13 && $ra != 13 && $ra != $rt && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:X, book:I, page:55, Fixed-Point, P1, lwzux # Load Word and Zero with Update Indexed
LWZUX PPC64LE 011111 rt:5 ra:5 rb:5 00001101110 \
!constraints { $rt != 1 && $ra > 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13 && $ra != $rt && $ra != $rb && $rt != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:55, Fixed-Point, P1, lwzx # Load Word and Zero Indexed
LWZX PPC64LE 011111 rt:5 ra:5 rb:5 00000101110 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13 && $ra != $rt && $ra != $rb && $rt != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:DS, book:I, page:618, Vector-Scalar_Extension, v3.0, lxsd # Load VSX Scalar Doubleword
LXSD PPC64LE 111001 vrt:5 ra:5 imm:14 10 \
!constraints { $ra > 1 && $ra != 13 && $imm <= 8176; } \
!memory { reg_plus_imm($ra, $imm << 2); }

@ format:X, book:I, page:619, Vector-Scalar_Extension, v2.06, lxsdx # Load VSX Scalar Doubleword Indexed
LXSDX PPC64LE 011111 t:5 ra:5 rb:5 1001001100 tx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:620, Vector-Scalar_Extension, v3.0, lxsibzx # Load VSX Scalar as Integer Byte & Zero Indexed
LXSIBZX PPC64LE 011111 t:5 ra:5 rb:5 1100001101 tx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:620, Vector-Scalar_Extension, v3.0, lxsihzx # Load VSX Scalar as Integer Halfword & Zero Indexed
LXSIHZX PPC64LE 011111 t:5 ra:5 rb:5 1100101101 tx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:621, Vector-Scalar_Extension, v2.07, lxsiwax # Load VSX Scalar as Integer Word Algebraic Indexed
LXSIWAX PPC64LE 011111 t:5 ra:5 rb:5 0001001100 tx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:622, Vector-Scalar_Extension, v2.07, lxsiwzx # Load VSX Scalar as Integer Word & Zero Indexed
LXSIWZX PPC64LE 011111 t:5 ra:5 rb:5 0000001100 tx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:DS, book:I, page:623, Vector-Scalar_Extension, v3.0, lxssp # Load VSX Scalar Single-Precision
LXSSP PPC64LE 111001 vrt:5 ra:5 imm:14 11 \
!constraints { $ra > 1 && $ra != 13 && $imm <= 8176; } \
!memory { reg_plus_imm($ra, $imm << 2); }

@ format:X, book:I, page:624, Vector-Scalar_Extension, v2.07, lxsspx # Load VSX Scalar Single-Precision Indexed
LXSSPX PPC64LE 011111 t:5 ra:5 rb:5 1000001100 tx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:DQ, book:I, page:625, Vector-Scalar_Extension, v3.0, lxv # Load VSX Vector
LXV PPC64LE 111101 t:5 ra:5 imm:12 tx:1 001 \
!constraints { $ra > 1 && $ra != 13 && $imm <= 2032; } \
!memory { reg_plus_imm($ra, $imm << 4); }

@ format:X, book:I, page:626, Vector-Scalar_Extension, v3.0, lxvb16x # Load VSX Vector Byte*16 Indexed
LXVB16X PPC64LE 011111 t:5 ra:5 rb:5 1101101100 tx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:627, Vector-Scalar_Extension, v2.06, lxvd2x # Load VSX Vector Doubleword*2 Indexed
LXVD2X PPC64LE 011111 t:5 ra:5 rb:5 1101001100 tx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:641, Vector-Scalar_Extension, v2.06, lxvdsx # Load VSX Vector Doubleword & Splat Indexed
LXVDSX PPC64LE 011111 t:5 ra:5 rb:5 0101001100 tx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:642, Vector-Scalar_Extension, v3.0, lxvh8x # Load VSX Vector Halfword*8 Indexed
LXVH8X PPC64LE 011111 t:5 ra:5 rb:5 1100101100 tx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:628, Vector-Scalar_Extension, v3.1, Skip, lxvkq # Load VSX Vector Special Value Quadword
LXVKQ PPC64LE 111100 a:5 11111 b:5 0101101000 rc:1

@ format:X, book:I, page:629, Vector-Scalar_Extension, v3.0, lxvl # Load VSX Vector with Length
LXVL PPC64LE 011111 t:5 ra:5 rb:5 0100001101 tx:1 \
!constraints { $ra > 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg($ra); }

@ format:X, book:I, page:631, Vector-Scalar_Extension, v3.0, lxvll # Load VSX Vector with Length Left-justified
LXVLL PPC64LE 011111 t:5 ra:5 rb:5 0100101101 tx:1 \
!constraints { $ra > 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg($ra); }

@ format:DQ, book:I, page:633, Vector-Scalar_Extension, v3.1, Skip, lxvp # Load VSX Vector Paired
LXVP PPC64LE 000110 a:22 0000

@ format:X, book:I, page:634, Vector-Scalar_Extension, v3.1, Skip, lxvpx # Load VSX Vector Paired Indexed
LXVPX PPC64LE 011111 a:15 01010011010

@ format:X, book:I, page:635, Vector-Scalar_Extension, v3.1, Skip, lxvrbx # Load VSX Vector Rightmost Byte Indexed
LXVRBX PPC64LE 011111 a:15 0000001101 rc:1

@ format:X, book:I, page:636, Vector-Scalar_Extension, v3.1, Skip, lxvrdx # Load VSX Vector Rightmost Doubleword Indexed
LXVRDX PPC64LE 011111 a:15 0001101101 rc:1

@ format:X, book:I, page:637, Vector-Scalar_Extension, v3.1, Skip, lxvrhx # Load VSX Vector Rightmost Halfword Indexed
LXVRHX PPC64LE 011111 a:15 0000101101 rc:1

@ format:X, book:I, page:638, Vector-Scalar_Extension, v3.1, Skip, lxvrwx # Load VSX Vector Rightmost Word Indexed
LXVRWX PPC64LE 011111 a:15 0001001101 rc:1

@ format:X, book:I, page:643, Vector-Scalar_Extension, v2.06, lxvw4x # Load VSX Vector Word*4 Indexed
LXVW4X PPC64LE 011111 t:5 ra:5 rb:5 1100001100 tx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:644, Vector-Scalar_Extension, v3.0, lxvwsx # Load VSX Vector Word & Splat Indexed
LXVWSX PPC64LE 011111 t:5 ra:5 rb:5 0101101100 tx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:639, Vector-Scalar_Extension, v3.0, lxvx # Load VSX Vector Indexed
LXVX PPC64LE 011111 t:5 ra:5 rb:5 0100001100 tx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:VA, book:I, page:87, Fixed-Point, v3.0, maddhd # Multiply-Add High Doubleword
MADDHD PPC64LE 000100 rt:5 ra:5 rb:5 rc:5 110000 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rc != 1 && $rt != 13 && $ra != 13 && $rb != 13 && $rc != 13; }

@ format:VA, book:I, page:88, Fixed-Point, v3.0, maddhdu # Multiply-Add High Doubleword Unsigned
MADDHDU PPC64LE 000100 rt:5 ra:5 rb:5 rc:5 110001 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rc != 1 && $rt != 13 && $ra != 13 && $rb != 13 && $rc != 13; }

@ format:VA, book:I, page:88, Fixed-Point, v3.0, maddld # Multiply-Add Low Doubleword
MADDLD PPC64LE 000100 rt:5 ra:5 rb:5 rc:5 110011 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rc != 1 && $rt != 13 && $ra != 13 && $rb != 13 && $rc != 13; }

@ format:XL, book:I, page:46, Branch, P1, mcrf # Move Condition Register Field
MCRF PPC64LE 010011 bf:3 00 bfa:3 000000000000000000

@ format:X, book:I, page:188, Floating-Point, P1, mcrfs # Move to Condition Register from FPSCR
MCRFS PPC64LE 111111 bf:3 00 bfa:3 000000000010000000

@ format:X, book:I, page:130, Fixed-Point, v3.0, mcrxrx # Move to CR from XER Extended
MCRXRX PPC64LE 011111 bf:3 00000000000010010000000

@ format:XFX, book:I, page:1113, Branch_History_Rolling_Buffer, v2.07, BHRB, mfbhrbe # Move From BHRB
MFBHRBE PPC64LE 011111 rt:5 bhrbe:10 01001011100 \
!constraints { $rt != 1 && $rt != 13; }

@ format:XFX, book:I, page:131, Fixed-Point, P1, mfcr # Move From Condition Register
MCFR PPC64LE 011111 rt:5 000000000000000100110 \
!constraints { $rt != 1 && $rt != 13; }

@ format:X, book:I, page:186, Floating-Point, P1, mffs[.] # Move From FPSCR
MFFS PPC64LE 111111 frt:5 000000000010010001110
MFFSd PPC64LE 111111 frt:5 000000000010010001111

@ format:X, book:I, page:186, Floating-Point, v3.0B, Skip, mffscdrn # Move From FPSCR Control & Set DRN
MFFSCDRN PPC64LE 111111 a:5 10100 b:5 10010001110

@ format:X, book:I, page:187, Floating-Point, v3.0B, Skip, mffscdrni # Move From FPSCR Control & Set DRN Immediate
MFFSCDRNI PPC64LE 111111 a:5 1010100 b:3 10010001110

@ format:X, book:I, page:186, Floating-Point, v3.0B, Skip, mffsce # Move From FPSCR & Clear Enables
MFFSCE PPC64LE 111111 a:5 000010000010010001110

@ format:X, book:I, page:187, Floating-Point, v3.0B, Skip, mffscrn # Move From FPSCR Control & Set RN
MFFSCRN PPC64LE 111111 a:5 10110 b:5 10010001110

@ format:X, book:I, page:187, Floating-Point, v3.0B, Skip, mffscrni # Move From FPSCR Control & Set RN Immediate
MFFSCRNI PPC64LE 111111 a:5 10111000 b:2 10010001110

@ format:X, book:I, page:187, Floating-Point, v3.0B, Skip, mffsl # Move From FPSCR Lightweight
MFFSL PPC64LE 111111 a:5 110000000010010001110

@ format:X, book:III, page:1187, Fixed-Point, P1, P, Skip, mfmsr # Move From MSR
MFMSR PPC64LE 011111 a:5 000000000000010100110

@ format:XFX, book:I, page:131, Fixed-Point, v2.01, mfocrf # Move From One Condition Register Field
MFOCRF PPC64LE 011111 rt:5 1 fxm:8 000000100110 \
!constraints { $rt != 1 && $rt != 13; }

@ format:XFX, book:I, page:129, Fixed-Point, book:III, page:1184, Fixed-Point, P1, O, Skip, mfspr # Move From Special Purpose Register
MFSPR PPC64LE 011111 a:15 01010100110

@ format:XFX, book:II, page:1104, Time_Base, PPC, Skip, mftb # Move From Time Base
MFTB PPC64LE 011111 a:15 01011100110

@ format:VX, book:I, page:501, Vector, v2.03, AltiVec, mfvscr # Move From Vector Status and Control Register
MFVSCR PPC64LE 000100 vrt:5 000000000011000000100

@ format:X, book:I, page:123, Fixed-Point, v2.07, mfvsrd # Move From VSR Doubleword
MFVSRD PPC64LE 011111 s:5 ra:5 000000000110011 sx:1 \
!constraints { $ra != 1 && $ra != 13; }

@ format:X, book:I, page:123, Fixed-Point, v3.0, mfvsrld # Move From VSR Lower Doubleword
MFVSRLD PPC64LE 011111 s:5 ra:5 000000100110011 sx:1 \
!constraints { $ra != 1 && $ra != 13; }

@ format:X, book:I, page:124, Fixed-Point, v2.07, mfvsrwz # Move From VSR Word and Zero
MFVSRWZ PPC64LE 011111 s:5 ra:5 000000001110011 sx:1 \
!constraints { $ra != 1 && $ra != 13; }

@ format:X, book:I, page:91, Fixed-Point, v3.0, modsd # Modulo Signed Doubleword
MODSD PPC64LE 011111 rt:5 ra:5 rb:5 11000010010 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:X, book:I, page:85, Fixed-Point, v3.0, modsw # Modulo Signed Word
MODSW PPC64LE 011111 rt:5 ra:5 rb:5 11000010110 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:X, book:I, page:91, Fixed-Point, v3.0, modud # Modulo Unsigned Doubleword
MODUD PPC64LE 011111 rt:5 ra:5 rb:5 01000010010 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:X, book:I, page:85, Fixed-Point, v3.0, moduw # Modulo Unsigned Word
MODUW PPC64LE 011111 rt:5 ra:5 rb:5 01000010110 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:X, book:III, page:1349, Processor_Control, v2.07, HV, Skip, msgclr # Message Clear
MSGCLR PPC64LE 0111110000000000 a:5 00111011100

@ format:X, book:III, page:1351, Processor_Control, v2.07, P, Skip, msgclrp # Message Clear Privileged
MSGCLRP PPC64LE 0111110000000000 a:5 00101011100

@ format:X, book:III, page:1348, Processor_Control, v3.0C, UV, Skip, msgclru # Ultravisor Message Clear
MSGCLRU PPC64LE 0111110000000000 a:5 00011011100

@ format:X, book:III, page:1348, Processor_Control, v2.07, HV, Skip, msgsnd # Message Send
MSGSND PPC64LE 0111110000000000 a:5 00110011100

@ format:X, book:III, page:1350, Processor_Control, v2.07, P, Skip, msgsndp # Message Send Privileged
MSGSNDP PPC64LE 0111110000000000 a:5 00100011100

@ format:SendX, book:III, page:1347, Processor_Control, v3.0C, UV, Skip, msgsndu # Ultravisor Message
MSGSNDU PPC64LE 0111110000000000 a:5 00010011100

@ format:X, book:III, page:1351, Processor_Control, v3.0, HV, Skip, msgsync # Message Synchronize
MSGSYNC PPC64LE 01111100000000000000011011101100

@ format:XFX, book:I, page:130, Fixed-Point, P1, mtcrf # Move To Condition Register Fields
MTCRF PPC64LE 011111 rs:5 0 fxm:8 000100100000 \
!constraints { $rs != 1 && $rs != 13; }

@ format:X, book:I, page:189, Floating-Point, P1, mtfsb0[.] # Move To FPSCR Bit 0
MTFSB0 PPC64LE 111111 bt:5 000000000000010001100
MTFSB0d PPC64LE 111111 bt:5 000000000000010001101

@ format:X, book:I, page:189, Floating-Point, P1, mtfsb1[.] # Move To FPSCR Bit 1
MTFSB1 PPC64LE 111111 bt:5 000000000000001001100
MTFSB1d PPC64LE 111111 bt:5 000000000000001001101

@ format:XFL, book:I, page:188, Floating-Point, P1, mtfsf[.] # Move To FPSCR Fields
MTFSF PPC64LE 111111 l:1 flm:8 w:1 frb:5 10110001110
MTFSFd PPC64LE 111111 l:1 flm:8 w:1 frb:5 10110001111

@ format:X, book:I, page:188, Floating-Point, P1, mtfsfi[.] # Move To FPSCR Field Immediate
MTFSFI PPC64LE 111111 bf:3 000000 w:1 u:4 000100001100
MTFSFId PPC64LE 111111 bf:3 000000 w:1 u:4 000100001101

@ format:X, book:III, page:1185, Fixed-Point, P1, P, Skip, mtmsr # Move To MSR
MTMSR PPC64LE 011111 a:5 0000 b:1 0000000100100100

@ format:X, book:III, page:1186, Fixed-Point, PPC, P, Skip, mtmsrd # Move To MSR Doubleword
MTMSRD PPC64LE 011111 a:5 0000 b:1 0000000101100100

@ format:XFX, book:I, page:130, Fixed-Point, v2.01, mtocrf # Move To One Condition Register Field
MTOCRF PPC64LE 011111 rs:5 1 fxm:8 000100100000 \
!constraints { $rs != 1 && $rs != 13; }

@ format:XFX, book:I, page:127, Fixed-Point, book:III, page:1182, Fixed-Point, P1, O, Skip, mtspr # Move To Special Purpose Register
MTSPR PPC64LE 011111 a:15 01110100110

@ format:VX, book:I, page:501, Vector, v2.03, AltiVec, mtvscr # Move To Vector Status and Control Register
MTVSCR PPC64LE 0001000000000000 vrb:5 11001000100

@ format:VX, book:I, page:468, Vector, v3.1, Skip, mtvsrbm # Move to VSR Byte Mask
MTVSRBM PPC64LE 000100 a:5 10000 b:5 11001000010

@ format:DX, book:I, page:470, Vector, v3.1, Skip, mtvsrbmi # Move To VSR Byte Mask Immediate
MTVSRBMI PPC64LE 000100 a:20 01010 b:1

@ format:X, book:I, page:124, Fixed-Point, v2.07, mtvsrd # Move To VSR Doubleword
MTVSRD PPC64LE 011111 t:5 ra:5 000000010110011 tx:1 \
!constraints { $ra != 1 && $ra != 13; }

@ format:X, book:I, page:126, Fixed-Point, v3.0, mtvsrdd # Move To VSR Double Doubleword
MTVSRDD PPC64LE 011111 t:5 ra:5 rb:5 0110110011 tx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13; }

@ format:VX, book:I, page:469, Vector, v3.1, Skip, mtvsrdm # Move to VSR Doubleword Mask
MTVSRDM PPC64LE 000100 a:5 10011 b:5 11001000010

@ format:VX, book:I, page:468, Vector, v3.1, Skip, mtvsrhm # Move to VSR Halfword Mask
MTVSRHM PPC64LE 000100 a:5 10001 b:5 11001000010

@ format:VX, book:I, page:470, Vector, v3.1, Skip, mtvsrqm # Move to VSR Quadword Mask
MTVSRQM PPC64LE 000100 a:5 10100 b:5 11001000010

@ format:X, book:I, page:125, Fixed-Point, v2.07, mtvsrwa # Move To VSR Word Algebraic
MTVSRWA PPC64LE 011111 t:5 ra:5 000000011010011 tx:1 \
!constraints { $ra != 1 && $ra != 13; }

@ format:VX, book:I, page:469, Vector, v3.1, Skip, mtvsrwm # Move to VSR Word Mask
MTVSRWM PPC64LE 000100 a:5 10010 b:5 11001000010

@ format:X, book:I, page:126, Fixed-Point, v3.0, mtvsrws # Move To VSR Word & Splat
MTVSRWS PPC64LE 011111 t:5 ra:5 000000110010011 tx:1 \
!constraints { $ra != 1 && $ra != 13; }

@ format:X, book:I, page:125, Fixed-Point, v2.07, mtvsrwz # Move To VSR Word and Zero
MTVSRWZ PPC64LE 011111 t:5 ra:5 000000011110011 tx:1 \
!constraints { $ra != 1 && $ra != 13; }

@ format:XO, book:I, page:87, Fixed-Point, PPC, SR, PPC64, mulhd[.] # Multiply High Doubleword
MULHD PPC64LE 011111 rt:5 ra:5 rb:5 00010010010 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
MULHDd PPC64LE 011111 rt:5 ra:5 rb:5 00010010011 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:XO, book:I, page:87, Fixed-Point, PPC, SR, PPC64, mulhdu[.] # Multiply High Doubleword Unsigned
MULHDU PPC64LE 011111 rt:5 ra:5 rb:5 00000010010 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
MULHDUd PPC64LE 011111 rt:5 ra:5 rb:5 00000010011 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:XO, book:I, page:81, Fixed-Point, PPC, SR, mulhw[.] # Multiply High Word
MULHW PPC64LE 011111 rt:5 ra:5 rb:5 00010010110 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
MULHWd PPC64LE 011111 rt:5 ra:5 rb:5 00010010111 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:XO, book:I, page:81, Fixed-Point, PPC, SR, mulhwu[.] # Multiply High Word Unsigned
MULHWU PPC64LE 011111 rt:5 ra:5 rb:5 00000010110 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
MULHWUd PPC64LE 011111 rt:5 ra:5 rb:5 00000010111 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:XO, book:I, page:87, Fixed-Point, PPC, SR, PPC64, mulld[o][.] # Multiply Low Doubleword
MULLD PPC64LE 011111 rt:5 ra:5 rb:5 00111010010 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
MULLDd PPC64LE 011111 rt:5 ra:5 rb:5 00111010011 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
MULLDo PPC64LE 011111 rt:5 ra:5 rb:5 10111010010 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
MULLDod PPC64LE 011111 rt:5 ra:5 rb:5 10111010011 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:D, book:I, page:81, Fixed-Point, P1, mulli # Multiply Low Immediate
MULLI PPC64LE 000111 rt:5 ra:5 imm:16 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }

@ format:XO, book:I, page:81, Fixed-Point, P1, SR, mullw[o][.] # Multiply Low Word
MULLW PPC64LE 011111 rt:5 ra:5 rb:5 00111010110 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
MULLWd PPC64LE 011111 rt:5 ra:5 rb:5 00111010111 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
MULLWo PPC64LE 011111 rt:5 ra:5 rb:5 10111010110 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
MULLWod PPC64LE 011111 rt:5 ra:5 rb:5 10111010111 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:X, book:I, page:100, Fixed-Point, P1, SR, nand[.] # NAND
NAND PPC64LE 011111 rs:5 ra:5 rb:5 01110111000 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }
NANDd PPC64LE 011111 rs:5 ra:5 rb:5 01110111001 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }

@ format:XO, book:I, page:80, Fixed-Point, P1, SR, neg[o][.] # Negate
NEG PPC64LE 011111 rt:5 ra:5 0000000011010000 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }
NEGd PPC64LE 011111 rt:5 ra:5 0000000011010001 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }
NEGo PPC64LE 011111 rt:5 ra:5 0000010011010000 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }
NEGod PPC64LE 011111 rt:5 ra:5 0000010011010001 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }

@ format:X, book:I, page:101, Fixed-Point, P1, SR, nor[.] # NOR
NOR PPC64LE 011111 rs:5 ra:5 rb:5 00011111000 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }
NORd PPC64LE 011111 rs:5 ra:5 rb:5 00011111001 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }

@ format:X, book:I, page:101, Fixed-Point, P1, SR, or[.] # OR
OR PPC64LE 011111 rs:5 ra:5 rb:5 01101111000 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }
ORd PPC64LE 011111 rs:5 ra:5 rb:5 01101111001 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }

@ format:X, book:I, page:101, Fixed-Point, P1, SR, orc[.] # OR with Complement
ORC PPC64LE 011111 rs:5 ra:5 rb:5 01100111000 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }
ORCd PPC64LE 011111 rs:5 ra:5 rb:5 01100111001 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }

@ format:D, book:I, page:99, Fixed-Point, P1, ori # OR Immediate
ORI PPC64LE 011000 rs:5 ra:5 imm:16 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:D, book:I, page:100, Fixed-Point, P1, oris # OR Immediate Shifted
ORIS PPC64LE 011001 rs:5 ra:5 imm:16 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:MLS:D, book:I, page:76, Fixed-Point, v3.1, Skip, paddi # Prefixed Add Immediate
PADDI PPC64LE 00000110000 a:1 00 b:18 001110 c:26

@ format:X, book:II, page:1078, Storage_Control, v3.0, Skip, paste[.] # Paste
PASTE PPC64LE 0111110000 a:11 11100001100
PASTEd PPC64LE 0111110000 a:11 11100001101

@ format:X, book:I, page:106, Fixed-Point, v3.1, Skip, pdepd # Parallel Bits Deposit Doubleword
PDEPD PPC64LE 011111 a:15 00100111000

@ format:X, book:I, page:106, Fixed-Point, v3.1, Skip, pextd # Parallel Bits Extract Doubleword
PEXTD PPC64LE 011111 a:15 00101111000

@ format:MLS:D, book:I, page:52, Fixed-Point, v3.1, Skip, plbz # Prefixed Load Byte and Zero
PLBZ PPC64LE 00000110000 a:1 00 b:18 100010 c:26

@ format:8LS:D, book:I, page:57, Fixed-Point, v3.1, Skip, pld # Prefixed Load Doubleword
PLD PPC64LE 00000100000 a:1 00 b:18 111001 c:26

@ format:MLS:D, book:I, page:156, Floating-Point, v3.1, Skip, plfd # Prefixed Load Floating-Point Double
PLFD PPC64LE 00000110000 a:1 00 b:18 110010 c:26

@ format:MLS:D, book:I, page:154, Floating-Point, v3.1, Skip, plfs # Prefixed Load Floating-Point Single
PLFS PPC64LE 00000110000 a:1 00 b:18 110000 c:26

@ format:MLS:D, book:I, page:54, Fixed-Point, v3.1, Skip, plha # Prefixed Load Halfword Algebraic
PLHA PPC64LE 00000110000 a:1 00 b:18 101010 c:26

@ format:MLS:D, book:I, page:53, Fixed-Point, v3.1, Skip, plhz # Prefixed Load Halfword and Zero
PLHZ PPC64LE 00000110000 a:1 00 b:18 101000 c:26

@ format:8LS:D, book:I, page:65, Fixed-Point, v3.1, Skip, plq # Prefixed Load Quadword
PLQ PPC64LE 00000100000 a:1 00 b:18 111000 c:26

@ format:8LS:D, book:I, page:56, Fixed-Point, v3.1, Skip, plwa # Prefixed Load Word Algebraic
PLWA PPC64LE 00000100000 a:1 00 b:18 101001 c:26

@ format:MLS:D, book:I, page:55, Fixed-Point, v3.1, Skip, plwz # Prefixed Load Word and Zero
PLWZ PPC64LE 00000110000 a:1 00 b:18 100000 c:26

@ format:8LS:D, book:I, page:618, Vector-Scalar_Extension, v3.1, Skip, plxsd # Prefixed Load VSX Scalar Doubleword
PLXSD PPC64LE 00000100000 a:1 00 b:18 101010 c:26

@ format:8LS:D, book:I, page:623, Vector-Scalar_Extension, v3.1, Skip, plxssp # Prefixed Load VSX Scalar Single-Precision
PLXSSP PPC64LE 00000100000 a:1 00 b:18 101011 c:26

@ format:8LS:D, book:I, page:625, Vector-Scalar_Extension, v3.1, Skip, plxv # Prefixed Load VSX Vector
PLXV PPC64LE 00000100000 a:1 00 b:18 11001 c:27

@ format:8LS:D, book:I, page:633, Vector-Scalar_Extension, v3.1, Skip, plxvp # Prefixed Load VSX Vector Paired
PLXVP PPC64LE 00000100000 a:1 00 b:18 111010 c:26

@ format:MMIRR:XX3, book:I, page:836, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvbf16ger2 # Prefixed Masked VSX Vector bfloat16 GER (Rank-2 Update)
PMXVBF16GER2 PPC64LE 0000011110010000 a:2 000000 b:8 111011 c:3 00 d:10 00110011 e:2 0

@ format:MMIRR:XX3, book:I, page:836, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvbf16ger2nn # Prefixed Masked VSX Vector bfloat16 GER (Rank-2 Update) Negative multiply, Negative accumulate
PMXVBF16GER2NN PPC64LE 0000011110010000 a:2 000000 b:8 111011 c:3 00 d:10 11110010 e:2 0

@ format:MMIRR:XX3, book:I, page:836, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvbf16ger2np # Prefixed Masked VSX Vector bfloat16 GER (Rank-2 Update) Negative multiply, Positive accumulate
PMXVBF16GER2NP PPC64LE 0000011110010000 a:2 000000 b:8 111011 c:3 00 d:10 01110010 e:2 0

@ format:MMIRR:XX3, book:I, page:836, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvbf16ger2pn # Prefixed Masked VSX Vector bfloat16 GER (Rank-2 Update) Positive multiply, Negative accumulate
PMXVBF16GER2PN PPC64LE 0000011110010000 a:2 000000 b:8 111011 c:3 00 d:10 10110010 e:2 0

@ format:MMIRR:XX3, book:I, page:836, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvbf16ger2pp # Prefixed Masked VSX Vector bfloat16 GER (Rank-2 Update) Positive multiply, Positive accumulate
PMXVBF16GER2PP PPC64LE 0000011110010000 a:2 000000 b:8 111011 c:3 00 d:10 00110010 e:2 0

@ format:MMIRR:XX3, book:I, page:880, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvf16ger2 # Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update)
PMXVF16GER2 PPC64LE 0000011110010000 a:2 000000 b:8 111011 c:3 00 d:10 00010011 e:2 0

@ format:MMIRR:XX3, book:I, page:880, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvf16ger2nn # Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update) Negative multiply, Negative accumulate
PMXVF16GER2NN PPC64LE 0000011110010000 a:2 000000 b:8 111011 c:3 00 d:10 11010010 e:2 0

@ format:MMIRR:XX3, book:I, page:880, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvf16ger2np # Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update) Negative multiply, Positive accumulate
PMXVF16GER2NP PPC64LE 0000011110010000 a:2 000000 b:8 111011 c:3 00 d:10 01010010 e:2 0

@ format:MMIRR:XX3, book:I, page:880, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvf16ger2pn # Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update) Positive multiply, Negative accumulate
PMXVF16GER2PN PPC64LE 0000011110010000 a:2 000000 b:8 111011 c:3 00 d:10 10010010 e:2 0

@ format:MMIRR:XX3, book:I, page:880, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvf16ger2pp # Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update) Positive multiply, Positive accumulate
PMXVF16GER2PP PPC64LE 0000011110010000 a:2 000000 b:8 111011 c:3 00 d:10 00010010 e:2 0

@ format:MMIRR:XX3, book:I, page:884, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvf32ger # Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update)
PMXVF32GER PPC64LE 000001111001000000000000 a:8 111011 b:3 00 c:10 00011011 d:2 0

@ format:MMIRR:XX3, book:I, page:884, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvf32gernn # Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update) Negative multiply, Negative accumulate
PMXVF32GERNN PPC64LE 000001111001000000000000 a:8 111011 b:3 00 c:10 11011010 d:2 0

@ format:MMIRR:XX3, book:I, page:884, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvf32gernp # Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update) Negative multiply, Positive accumulate
PMXVF32GERNP PPC64LE 000001111001000000000000 a:8 111011 b:3 00 c:10 01011010 d:2 0

@ format:MMIRR:XX3, book:I, page:884, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvf32gerpn # Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update) Positive multiply, Negative accumulate
PMXVF32GERPN PPC64LE 000001111001000000000000 a:8 111011 b:3 00 c:10 10011010 d:2 0

@ format:MMIRR:XX3, book:I, page:884, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvf32gerpp # Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update) Positive multiply, Positive accumulate
PMXVF32GERPP PPC64LE 000001111001000000000000 a:8 111011 b:3 00 c:10 00011010 d:2 0

@ format:MMIRR:XX3, book:I, page:888, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvf64ger # Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update)
PMXVF64GER PPC64LE 000001111001000000000000 a:8 111011 b:3 00 c:10 00111011 d:2 0

@ format:MMIRR:XX3, book:I, page:888, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvf64gernn # Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update) Negative multiply, Negative accumulate
PMXVF64GERNN PPC64LE 000001111001000000000000 a:8 111011 b:3 00 c:10 11111010 d:2 0

@ format:MMIRR:XX3, book:I, page:888, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvf64gernp # Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update) Negative multiply, Positive accumulate
PMXVF64GERNP PPC64LE 000001111001000000000000 a:8 111011 b:3 00 c:10 01111010 d:2 0

@ format:MMIRR:XX3, book:I, page:888, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvf64gerpn # Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update) Positive multiply, Negative accumulate
PMXVF64GERPN PPC64LE 000001111001000000000000 a:8 111011 b:3 00 c:10 10111010 d:2 0

@ format:MMIRR:XX3, book:I, page:888, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvf64gerpp # Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update) Positive multiply, Positive accumulate
PMXVF64GERPP PPC64LE 000001111001000000000000 a:8 111011 b:3 00 c:10 00111010 d:2 0

@ format:MMIRR:XX3, book:I, page:900, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvi16ger2 # Prefixed Masked VSX Vector 16-bit Signed Integer GER (rank-2 update)
PMXVI16GER2 PPC64LE 0000011110010000 a:2 000000 b:8 111011 c:3 00 d:10 01001011 e:2 0

@ format:MMIRR:XX3, book:I, page:900, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvi16ger2pp # Prefixed Masked VSX Vector 16-bit Signed Integer GER (rank-2 update) Positive multiply, Positive accumulate
PMXVI16GER2PP PPC64LE 0000011110010000 a:2 000000 b:8 111011 c:3 00 d:10 01101011 e:2 0

@ format:MMIRR:XX3, book:I, page:902, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvi16ger2s # Prefixed Masked VSX Vector 16-bit Signed Integer GER (rank-2 update) with Saturation
PMXVI16GER2S PPC64LE 0000011110010000 a:2 000000 b:8 111011 c:3 00 d:10 00101011 e:2 0

@ format:MMIRR:XX3, book:I, page:902, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvi16ger2spp # Prefixed Masked VSX Vector 16-bit Signed Integer GER (rank-2 update) with Saturation Positive multiply, Positive accumulate
PMXVI16GER2SPP PPC64LE 0000011110010000 a:2 000000 b:8 111011 c:3 00 d:10 00101010 e:2 0

@ format:MMIRR:XX3, book:I, page:892, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvi4ger8 # Prefixed Masked VSX Vector 4-bit Signed Integer GER (rank-8 update)
PMXVI4GER8 PPC64LE 0000011110010000 a:16 111011 b:3 00 c:10 00100011 d:2 0

@ format:MMIRR:XX3, book:I, page:892, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvi4ger8pp # Prefixed Masked VSX Vector 4-bit Signed Integer GER (rank-8 update) Positive multiply, Positive accumulate
PMXVI4GER8PP PPC64LE 0000011110010000 a:16 111011 b:3 00 c:10 00100010 d:2 0

@ format:MMIRR:XX3, book:I, page:895, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvi8ger4 # Prefixed Masked VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update)
PMXVI8GER4 PPC64LE 0000011110010000 a:4 0000 b:8 111011 c:3 00 d:10 00000011 e:2 0

@ format:MMIRR:XX3, book:I, page:895, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvi8ger4pp # Prefixed Masked VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update) Positive multiply, Positive accumulate
PMXVI8GER4PP PPC64LE 0000011110010000 a:4 0000 b:8 111011 c:3 00 d:10 00000010 e:2 0

@ format:MMIRR:XX3, book:I, page:898, Vector-Scalar_Extension, v3.1, MMA, Skip, pmxvi8ger4spp # Prefixed Masked VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update) with Saturate Positive multiply, Positive accumulate
PMXVI8GER4SPP PPC64LE 0000011110010000 a:4 0000 b:8 111011 c:3 00 d:10 01100011 e:2 0

@ format:MRR:*, book:I, page:133, Fixed-Point, v3.1, Skip, pnop # Prefixed Nop
PNOP PPC64LE 00000111000000000000000000000000 a:32

@ format:X, book:I, page:103, Fixed-Point, v2.02, popcntb # Population Count Bytes
POPCNTB PPC64LE 011111 rs:5 ra:5 0000000011110100 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:X, book:I, page:104, Fixed-Point, v2.06, popcntd # Population Count Doubleword
POPCNTD PPC64LE 011111 rs:5 ra:5 0000001111110100 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:X, book:I, page:103, Fixed-Point, v2.06, popcntw # Population Count Words
POPCNTW PPC64LE 011111 rs:5 ra:5 0000001011110100 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:X, book:I, page:104, Fixed-Point, v2.05, prtyd # Parity Doubleword
PRTYD PPC64LE 011111 rs:5 ra:5 0000000101110100 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:X, book:I, page:103, Fixed-Point, v2.05, prtyw # Parity Word
PRTYW PPC64LE 011111 rs:5 ra:5 0000000100110100 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:MLS:D, book:I, page:59, Fixed-Point, v3.1, Skip, pstb # Prefixed Store Byte
PSTB PPC64LE 00000110000 a:1 00 b:18 100110 c:26

@ format:8LS:D, book:I, page:62, Fixed-Point, v3.1, Skip, pstd # Prefixed Store Doubleword
PSTD PPC64LE 00000100000 a:1 00 b:18 111101 c:26

@ format:MLS:D, book:I, page:161, Floating-Point, v3.1, Skip, pstfd # Prefixed Store Floating-Point Double
PSTFD PPC64LE 00000110000 a:1 00 b:18 110110 c:26

@ format:MLS:D, book:I, page:159, Floating-Point, v3.1, Skip, pstfs # Prefixed Store Floating-Point Single
PSTFS PPC64LE 00000110000 a:1 00 b:18 110100 c:26

@ format:MLS:D, book:I, page:60, Fixed-Point, v3.1, Skip, psth # Prefixed Store Halfword
PSTH PPC64LE 00000110000 a:1 00 b:18 101100 c:26

@ format:8LS:D, book:I, page:66, Fixed-Point, v3.1, Skip, pstq # Prefixed Store Quadword
PSTQ PPC64LE 00000100000 a:1 00 b:18 111100 c:26

@ format:MLS:D, book:I, page:61, Fixed-Point, v3.1, Skip, pstw # Prefixed Store Word
PSTW PPC64LE 00000110000 a:1 00 b:18 100100 c:26

@ format:8LS:D, book:I, page:646, Vector-Scalar_Extension, v3.1, Skip, pstxsd # Prefixed Store VSX Scalar Doubleword
PSTXSD PPC64LE 00000100000 a:1 00 b:18 101110 c:26

@ format:8LS:D, book:I, page:650, Vector-Scalar_Extension, v3.1, Skip, pstxssp # Prefixed Store VSX Scalar Single-Precision
PSTXSSP PPC64LE 00000100000 a:1 00 b:18 101111 c:26

@ format:8LS:D, book:I, page:652, Vector-Scalar_Extension, v3.1, Skip, pstxv # Prefixed Store VSX Vector
PSTXV PPC64LE 00000100000 a:1 00 b:18 11011 c:27

@ format:8LS:D, book:I, page:662, Vector-Scalar_Extension, v3.1, Skip, pstxvp # Prefixed Store VSX Vector Paired
PSTXVP PPC64LE 00000100000 a:1 00 b:18 111110 c:26

@ format:XL, book:I, page:1110, Branch_History_Rolling_Buffer, v2.07, EBB, Skip, rfebb # Return from Event Based Branch
RFEBB PPC64LE 01001100000000000000 a:1 00100100100

@ format:XL, book:III, page:1162, Branch, PPC, P, Skip, rfid # Return from Interrupt Doubleword
RFID PPC64LE 01001100000000000000000000100100

@ format:XL, book:III, page:1161, Branch, v3.0, P, Skip, rfscv # Return From System Call Vectored
RFSCV PPC64LE 01001100000000000000000010100100

@ format:MDS, book:I, page:111, Fixed-Point, PPC, SR, PPC64, rldcl[.] # Rotate Left Doubleword then Clear Left
RLDCL PPC64LE 011110 rs:5 ra:5 rb:5 mb:6 10000 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }
RLDCLd PPC64LE 011110 rs:5 ra:5 rb:5 mb:6 10001 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }

@ format:MDS, book:I, page:112, Fixed-Point, PPC, SR, PPC64, rldcr[.] # Rotate Left Doubleword then Clear Right
RLDCR PPC64LE 011110 rs:5 ra:5 rb:5 mb:6 10010 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }
RLDCRd PPC64LE 011110 rs:5 ra:5 rb:5 mb:6 10011 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }

@ format:MD, book:I, page:111, Fixed-Point, PPC, SR, PPC64, rldic[.] # Rotate Left Doubleword Immediate then Clear
RLDIC PPC64LE 011110 rs:5 ra:5 sh:5 mb:6 010 sha:1 0 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }
RLDICd PPC64LE 011110 rs:5 ra:5 sh:5 mb:6 010 sha:1 1 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:MD, book:I, page:110, Fixed-Point, PPC, SR, PPC64, rldicl[.] # Rotate Left Doubleword Immediate then Clear Left
RLDICL PPC64LE 011110 rs:5 ra:5 sh:5 mb:6 000 sha:1 0 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }
RLDICLd PPC64LE 011110 rs:5 ra:5 sh:5 mb:6 000 sha:1 1 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:MD, book:I, page:110, Fixed-Point, PPC, SR, PPC64, rldicr[.] # Rotate Left Doubleword Immediate then Clear Right
RLDICR PPC64LE 011110 rs:5 ra:5 sh:5 me:6 001 sha:1 0 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }
RLDICRd PPC64LE 011110 rs:5 ra:5 sh:5 me:6 001 sha:1 1 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:MD, book:I, page:112, Fixed-Point, PPC, SR, PPC64, rldimi[.] # Rotate Left Doubleword Immediate then Mask Insert
RLDIMI PPC64LE 011110 rs:5 ra:5 sh:5 me:6 011 sha:1 0 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }
RLDIMId PPC64LE 011110 rs:5 ra:5 sh:5 me:6 011 sha:1 1 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:M, book:I, page:108, Fixed-Point, P1, SR, rlwimi[.] # Rotate Left Word Immediate then Mask Insert
RLWIMI PPC64LE 010100 rs:5 ra:5 sh:5 mb:5 me:5 0 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }
RLWIMId PPC64LE 010100 rs:5 ra:5 sh:5 mb:5 me:5 1 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:M, book:I, page:107, Fixed-Point, P1, SR, rlwinm[.] # Rotate Left Word Immediate then AND with Mask
RLWINM PPC64LE 010101 rs:5 ra:5 sh:5 mb:5 me:5 0 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }
RLWINMd PPC64LE 010101 rs:5 ra:5 sh:5 mb:5 me:5 1 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:M, book:I, page:108, Fixed-Point, P1, SR, rlwnm[.] # Rotate Left Word then AND with Mask
RLWNM PPC64LE 010111 rs:5 ra:5 rb:5 mb:5 me:5 0 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }
RLWNMd PPC64LE 010111 rs:5 ra:5 rb:5 mb:5 me:5 1 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }

@ format:SC, book:I, page:47, Branch, PPC, Skip, sc # SystemCall
SC PPC64LE 01000100000000000000 lev:7 00010

@ format:SC, book:I, page:47, Branch, v3.0, Skip, scv # System Call Vectored
SCV PPC64LE 01000100000000000000 lev:7 00001

@ format:X, book:I, page:132, Fixed-Point, v3.0, setb # Set Boolean
SETB PPC64LE 011111 rt:5 bfa:3 000000000100000000 \
!constraints { $rt != 1 && $rt != 13; }

@ format:X, book:I, page:132, Fixed-Point, v3.1, Skip, setbc # Set Boolean Condition
SETBC PPC64LE 011111 a:10 0000001100000000

@ format:X, book:I, page:132, Fixed-Point, v3.1, Skip, setbcr # Set Boolean Condition Reverse
SETBCR PPC64LE 011111 a:10 0000001101000000

@ format:X, book:I, page:132, Fixed-Point, v3.1, Skip, setnbc # Set Negative Boolean Condition
SETNBC PPC64LE 011111 a:10 0000001110000000

@ format:X, book:I, page:132, Fixed-Point, v3.1, Skip, setnbcr # Set Negative Boolean Condition Reverse
SETNBCR PPC64LE 011111 a:10 0000001111000000

@ format:X, book:III, page:1242, Storage_Control, v2.05, P, SR, Skip, slbfee. # SLB Find Entry ESID
SLBFEED PPC64LE 011111 a:5 00000 b:5 11110100111

@ format:X, book:III, page:1237, Storage_Control, PPC, P, Skip, slbia # SLB Invalidate All
SLBIA PPC64LE 01111100 a:3 000000000001111100100

@ format:X, book:III, page:1239, Storage_Control, v3.0B, P, Skip, slbiag # SLB Invalidate All Global
SLBIAG PPC64LE 011111 a:5 00000 b:5 11010100100

@ format:X, book:III, page:1234, Storage_Control, PPC, P, Skip, slbie # SLB Invalidate Entry
SLBIE PPC64LE 0111110000000000 a:5 01101100100

@ format:X, book:III, page:1236, Storage_Control, v3.0, P, Skip, slbieg # SLB Invalidate Entry Global
SLBIEG PPC64LE 011111 a:5 00000 b:5 01110100100

@ format:X, book:III, page:1242, Storage_Control, v2.00, P, Skip, slbmfee # SLB Move From Entry ESID
SLBMFEE PPC64LE 011111 a:5 00000 b:5 11100100110

@ format:X, book:III, page:1241, Storage_Control, v2.00, P, Skip, slbmfev # SLB Move From Entry VSID
SLBMFEV PPC64LE 011111 a:5 00000 b:5 11010100110

@ format:X, book:III, page:1240, Storage_Control, v2.00, P, Skip, slbmte # SLB Move To Entry
SLBMTE PPC64LE 011111 a:5 00000 b:5 01100100100

@ format:X, book:III, page:1243, Storage_Control, v3.0, P, Skip, slbsync # SLB Synchronize
SLBSYNC PPC64LE 01111100000000000000001010100100

@ format:X, book:I, page:115, Fixed-Point, PPC, SR, PPC64, sld[.] # Shift Left Doubleword
SLD PPC64LE 011111 rs:5 ra:5 rb:5 00000110110 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }
SLDd PPC64LE 011111 rs:5 ra:5 rb:5 00000110111 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }

@ format:X, book:I, page:113, Fixed-Point, P1, SR, slw[.] # Shift Left Word
SLW PPC64LE 011111 rs:5 ra:5 rb:5 00000110000 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }
SLWd PPC64LE 011111 rs:5 ra:5 rb:5 00000110001 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }

@ format:X, book:I, page:115, Fixed-Point, PPC, SR, PPC64, srad[.] # Shift Right Algebraic Doubleword
SRAD PPC64LE 011111 rs:5 ra:5 rb:5 11000110100 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }
SRADd PPC64LE 011111 rs:5 ra:5 rb:5 11000110101 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }

@ format:XS, book:I, page:115, Fixed-Point, PPC, SR, PPC64, sradi[.] # Shift Right Algebraic Doubleword Immediate
SRADI PPC64LE 011111 rs:5 ra:5 sh:5 110011101 sha:1 0 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }
SRADId PPC64LE 011111 rs:5 ra:5 sh:5 110011101 sha:1 1 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:X, book:I, page:114, Fixed-Point, P1, SR, sraw[.] # Shift Right Algebraic Word
SRAW PPC64LE 011111 rs:5 ra:5 rb:5 11000110000 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }
SRAWd PPC64LE 011111 rs:5 ra:5 rb:5 11000110001 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }

@ format:X, book:I, page:114, Fixed-Point, P1, SR, srawi[.] # Shift Right Algebraic Word Immediate
SRAWI PPC64LE 011111 rs:5 ra:5 sh:5 11001110000 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }
SRAWId PPC64LE 011111 rs:5 ra:5 sh:5 11001110001 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:X, book:I, page:115, Fixed-Point, PPC, SR, PPC64, srd[.] # Shift Right Doubleword
SRD PPC64LE 011111 rs:5 ra:5 rb:5 10000110110 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }
SRDd PPC64LE 011111 rs:5 ra:5 rb:5 10000110111 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }

@ format:X, book:I, page:113, Fixed-Point, P1, SR, srw[.] # Shift Right Word
SRW PPC64LE 011111 rs:5 ra:5 rb:5 10000110000 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }
SRWd PPC64LE 011111 rs:5 ra:5 rb:5 10000110001 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }

@ format:D, book:I, page:59, Fixed-Point, P1, stb # Store Byte
STB PPC64LE 100110 rs:5 ra:5 imm:16 \
!constraints { $rs != 1 && $ra > 1 && $rs != 13 && $ra != 13 && $rs != $ra && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:X, book:III, page:1175, Fixed-Point, v2.05, HV, Skip, stbcix # Store Byte Caching Inhibited Indexed
STBCIX PPC64LE 011111 a:15 11110101010

@ format:X, book:II, page:1089, Storage_Control, v2.06, Skip, stbcx. # Store Byte Conditional Indexed
STBCXD PPC64LE 011111 a:15 10101101101

@ format:D, book:I, page:59, Fixed-Point, P1, stbu # Store Byte with Update
STBU PPC64LE 100111 rs:5 ra:5 imm:16 \
!constraints { $rs != 1 && $ra > 1 && $rs != 13 && $ra != 13 && $rs != $ra && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:X, book:I, page:59, Fixed-Point, P1, stbux # Store Byte with Update Indexed
STBUX PPC64LE 011111 rs:5 ra:5 rb:5 00111101110 \
!constraints { $rs != 1 && $ra > 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13 && $ra != $rs && $ra != $rb && $rs != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:59, Fixed-Point, P1, stbx # Store Byte Indexed
STBX PPC64LE 011111 rs:5 ra:5 rb:5 00110101110 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13 && $ra != $rs && $ra != $rb && $rs != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:DS, book:I, page:62, Fixed-Point, PPC, PPC64, std # Store Doubleword
STD PPC64LE 111110 rs:5 ra:5 imm:14 00 \
!constraints { $rs != 1 && $ra > 1 && $rs != 13 && $ra != 13 && $rs != $ra && $imm <= 8176; } \
!memory { reg_plus_imm($ra, $imm << 2); }

@ format:X, book:II, page:1085, Storage_Control, v3.0, AMO, Skip, stdat # Store Doubleword ATomic
STDAT PPC64LE 011111 a:15 10111001100

@ format:X, book:I, page:69, Fixed-Point, v2.06, stdbrx # Store Doubleword Byte-Reverse Indexed
STDBRX PPC64LE 011111 rs:5 ra:5 rb:5 10100101000 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13 && $ra != $rs && $ra != $rb && $rs != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:III, page:1175, Fixed-Point, v2.05, HV, Skip, stdcix # Store Doubleword Caching Inhibited Indexed
STDCIX PPC64LE 011111 a:15 11111101010

@ format:X, book:II, page:1092, Storage_Control, PPC, Skip, stdcx. # Store Doubleword Conditional Indexed
STDCXD PPC64LE 011111 a:15 00110101101

@ format:DS, book:I, page:62, Fixed-Point, PPC, PPC64, stdu # Store Doubleword with Update
STDU PPC64LE 111110 rs:5 ra:5 imm:14 01 \
!constraints { $rs != 1 && $ra > 1 && $rs != 13 && $ra != 13 && $rs != $ra && $imm <= 8176; } \
!memory { reg_plus_imm($ra, $imm << 2); }

@ format:X, book:I, page:63, Fixed-Point, PPC, PPC64, stdux # Store Doubleword with Update Indexed
STDUX PPC64LE 011111 rs:5 ra:5 rb:5 00101101010 \
!constraints { $rs != 1 && $ra > 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13 && $ra != $rs && $ra != $rb && $rs != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:62, Fixed-Point, PPC, PPC64, stdx # Store Doubleword Indexed
STDX PPC64LE 011111 rs:5 ra:5 rb:5 00100101010 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13 && $ra != $rs && $ra != $rb && $rs != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:D, book:I, page:161, Floating-Point, P1, stfd # Store Floating-Point Double
STFD PPC64LE 110110 frs:5 ra:5 imm:16 \
!constraints { $ra > 1 && $ra != 13 && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:DS, book:I, page:164, Floating-Point, v2.05, stfdp # Store Floating-Point Double Pair
STFDP PPC64LE 111101 frsp:5 ra:5 imm:14 00 \
!constraints { $frsp % 2 == 0 && $ra > 1 && $ra != 13 && $imm <= 8176; } \
!memory { reg_plus_imm($ra, $imm << 2); }

@ format:X, book:I, page:164, Floating-Point, v2.05, stfdpx # Store Floating-Point Double Pair Indexed
STFDPX PPC64LE 011111 frsp:5 ra:5 rb:5 11100101110 \
!constraints { $frsp % 2 == 0 && $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:D, book:I, page:161, Floating-Point, P1, stfdu # Store Floating-Point Double with Update
STFDU PPC64LE 110111 frs:5 ra:5 imm:16 \
!constraints { $ra > 1 && $ra != 13 && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:X, book:I, page:162, Floating-Point, P1, stfdux # Store Floating-Point Double with Update Indexed
STFDUX PPC64LE 011111 frs:5 ra:5 rb:5 10111101110 \
!constraints { $ra > 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:161, Floating-Point, P1, stfdx # Store Floating-Point Double Indexed
STFDX PPC64LE 011111 frs:5 ra:5 rb:5 10110101110 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:162, Floating-Point, PPC, stfiwx # Store Floating-Point as Integer Word Indexed
STFIWX PPC64LE 011111 fra:5 ra:5 rb:5 11110101110 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:D, book:I, page:159, Floating-Point, P1, stfs # Store Floating-Point Single
STFS PPC64LE 110100 frs:5 ra:5 imm:16 \
!constraints { $ra > 1 && $ra != 13 && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:D, book:I, page:159, Floating-Point, P1, stfsu # Store Floating-Point Single with Update
STFSU PPC64LE 110101 frs:5 ra:5 imm:16 \
!constraints { $ra > 1 && $ra != 13 && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:X, book:I, page:160, Floating-Point, P1, stfsux # Store Floating-Point Single with Update Indexed
STFSUX PPC64LE 011111 frs:5 ra:5 rb:5 10101101110 \
!constraints { $ra > 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:159, Floating-Point, P1, stfsx # Store Floating-Point Single Indexed
STFSX PPC64LE 011111 frs:5 ra:5 rb:5 10100 101110 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:D, book:I, page:60, Fixed-Point, P1, sth # Store Halfword
STH PPC64LE 101100 rs:5 ra:5 imm:16 \
!constraints { $rs != 1 && $ra > 1 && $rs != 13 && $ra != 13 && $rs != $ra && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:X, book:I, page:67, Fixed-Point, P1, sthbrx # Store Halfword Byte-Reverse Indexed
STHBRX PPC64LE 011111 rs:5 ra:5 rb:5 11100101100 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13 && $ra != $rs && $ra != $rb && $rs != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:III, page:1175, Fixed-Point, v2.05, HV, Skip, sthcix # Store Halfword Caching Inhibited Indexed
STHCIX PPC64LE 011111 a:15 11101101010

@ format:X, book:II, page:1090, Storage_Control, v2.06, Skip, sthcx. # Store Halfword Conditional Indexed
STHCXD PPC64LE 011111 a:15 10110101101

@ format:D, book:I, page:60, Fixed-Point, P1, sthu # Store Halfword with Update
STHU PPC64LE 101101 rs:5 ra:5 imm:16 \
!constraints { $rs != 1 && $ra > 1 && $rs != 13 && $ra != 13 && $rs != $ra && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:X, book:I, page:60, Fixed-Point, P1, sthux # Store Halfword with Update Indexed
STHUX PPC64LE 011111 rs:5 ra:5 rb:5 01101101110 \
!constraints { $rs != 1 && $ra > 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13 && $ra != $rs && $ra != $rb && $rs != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:60, Fixed-Point, P1, sthx # Store Halfword Indexed
STHX PPC64LE 011111 rs:5 ra:5 rb:5 01100101110 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13 && $ra != $rs && $ra != $rb && $rs != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

# STMW is not supported in little-endian mode
@ format:D, book:I, page:70, Fixed-Point, P1, stmw # Store Multiple Word
STMW PPC64BE 101111 rs:5 ra:5 imm:16 \
!constraints { $rs > 13 && $ra > 1 && $ra != 13 && $ra < $rs && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:XL, book:III, page:1165, Branch, v3.0, P, Skip, stop # Stop
STOP PPC64LE 01001100000000000000001011100100

@ format:DS, book:I, page:66, Fixed-Point, v2.03, stq # Store Quadword
STQ PPC64BE 111110 rsp:5 ra:5 imm:14 10 \
!constraints { $rsp % 2 == 0 && $ra > 1 && $ra != 13 && $rsp != $ra && $imm <= 8176; } \
!memory { reg_plus_imm($ra, $imm << 2); }

@ format:X, book:I, page:1095, Storage_Control, v2.07, Skip, stqcx. # Store Quadword Conditional Indexed
STQCXD PPC64LE 011111 a:15 00101101101

# STSWI is not supported in little-endian mode
@ format:X, book:I, page:73, Fixed-Point, P1, stswi # Store String Word Immediate
STSWI PPC64BE 011111 rs:5 ra:5 rb:5 10110101010 \
!constraints { \
    my $nb = $rb + ($rb ? 0 : 32); \
    my $regs = regs_wrapped($rs, $nb); \
    $ra > 1 && $ra != 13 && ($regs & ((1<<(31-1)) | (1<<(31-13)) | (1<<(31-$ra)))) == 0; \
} \
!memory { reg($ra); }

@ format:X, book:I, page:73, Fixed-Point, P1, stswx # Store String Word Indexed
STSWX PPC64LE 011111 rs:5 ra:5 rb:5 10100 101010 \
!constraints { \
    my $nb = irand(0x7f); \
    set_num("nb", $nb); \
    my $regs = regs_wrapped($rs, $nb); \
    $ra != 1 && $ra != 13 && $rb != 1 && $rb != 13 && $ra != $rb && \
        ( \
            (($ra != 0) && ($regs & ((1<<(31-1)) | (1<<(31-13)) | (1<<(31-$ra)))) == 0) \
            || \
            (($ra == 0) && ($regs & ((1<<(31-1)) | (1<<(31-13)) | (1<<(31-$rb)))) == 0) \
        ) \
} \
!memory { \
    write_mov_ri($ra, get_num("nb")); \
    insn32((31 << 26) | ($ra << 21) | ((1 & 31) << 16) | ((1 >> 5) << 11) | (467 << 1)); \
    reg_plus_reg($ra, $rb); \
}

@ format:X, book:I, page:277, Vector, v2.03, AltiVec, stvebx # Store Vector Element Byte Indexed
STVEBX PPC64LE 011111 vrs:5 ra:5 rb:5 00100001110 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:278, Vector, v2.03, AltiVec, stvehx # Store Vector Element Halfword Indexed
STVEHX PPC64LE 011111 vrs:5 ra:5 rb:5 00101001110 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:279, Vector, v2.03, AltiVec, stvewx # Store Vector Element Word Indexed
STVEWX PPC64LE 011111 vrs:5 ra:5 rb:5 00110001110 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:280, Vector, v2.03, AltiVec, stvx # Store Vector Indexed
STVX PPC64LE 011111 vrs:5 ra:5 rb:5 00111001110 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:280, Vector, v2.03, AltiVec, stvxl # Store Vector Indexed Last
STVXL PPC64LE 011111 vrs:5 ra:5 rb:5 01111001110 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:D, book:I, page:61, Fixed-Point, P1, stw # Store Word
STW PPC64LE 100100 rs:5 ra:5 imm:16 \
!constraints { $rs != 1 && $ra > 1 && $rs != 13 && $ra != 13 && $rs != $ra && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:X, book:II, page:1085, Storage_Control, v3.0, AMO, Skip, stwat # Store Word ATomic
STWAT PPC64LE 011111 a:15 10110001100

@ format:X, book:I, page:68, Fixed-Point, P1, stwbrx # Store Word Byte-Reverse Indexed
STWBRX PPC64LE 011111 rs:5 ra:5 rb:5 10100101100 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13 && $ra != $rs && $ra != $rb && $rs != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:III, page:1175, Fixed-Point, v2.05, HV, Skip, stwcix # Store Word Caching Inhibited Indexed
STWCIX PPC64LE 011111 a:15 11100101010

@ format:X, book:II, page:1091, Storage_Control, PPC, Skip, stwcx. # Store Word Conditional Indexed
STWCXD PPC64LE 011111 a:15 00100101101

@ format:D, book:I, page:61, Fixed-Point, P1, stwu # Store Word with Update
STWU PPC64LE 100101 rs:5 ra:5 imm:16 \
!constraints { $rs != 1 && $ra > 1 && $rs != 13 && $ra != 13 && $rs != $ra && $imm <= 32752; } \
!memory { reg_plus_imm($ra, $imm); }

@ format:X, book:I, page:61, Fixed-Point, P1, stwux # Store Word with Update Indexed
STWUX PPC64LE 011111 rs:5 ra:5 rb:5 00101101110 \
!constraints { $rs != 1 && $ra > 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13 && $ra != $rs && $ra != $rb && $rs != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:61, Fixed-Point, P1, stwx # Store Word Indexed
STWX PPC64LE 011111 rs:5 ra:5 rb:5 00100101110 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13 && $ra != $rs && $ra != $rb && $rs != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:DS, book:I, page:646, Vector-Scalar_Extension, v3.0, stxsd # Store VSX Scalar Doubleword
STXSD PPC64LE 111101 vrs:5 ra:5 imm:14 10 \
!constraints { $ra > 1 && $ra != 13 && $imm <= 4000; } \
!memory { reg_plus_imm($ra, $imm << 2); }

@ format:X, book:I, page:647, Vector-Scalar_Extension, v2.06, stxsdx # Store VSX Scalar Doubleword Indexed
STXSDX PPC64LE 011111 s:5 ra:5 rb:5 1011001100 sx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:648, Vector-Scalar_Extension, v3.0, stxsibx # Store VSX Scalar as Integer Byte Indexed
STXSIBX PPC64LE 011111 s:5 ra:5 rb:5 11100 01101 sx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:648, Vector-Scalar_Extension, v3.0, stxsihx # Store VSX Scalar as Integer Halfword Indexed
STXSIHX PPC64LE 011111 s:5 ra:5 rb:5 11101 01101 sx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:649, Vector-Scalar_Extension, v2.07, stxsiwx # Store VSX Scalar as Integer Word Indexed
STXSIWX PPC64LE 011111 s:5 ra:5 rb:5 00100 01100 sx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:DS, book:I, page:650, Vector-Scalar_Extension, v3.0, stxssp # Store VSX Scalar Single
STXSSP PPC64LE 111101 vrs:5 ra:5 imm:14 11 \
!constraints { $ra > 1 && $ra != 13 && $imm <= 8176; } \
!memory { reg_plus_imm($ra, $imm << 2); }

@ format:X, book:I, page:651, Vector-Scalar_Extension, v2.07, stxsspx # Store VSX Scalar Single-Precision Indexed
STXSSPX PPC64LE 011111 s:5 ra:5 rb:5 10100 01100 sx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:DQ, book:I, page:652, Vector-Scalar_Extension, v3.0, stxv # Store VSX Vector
STXV PPC64LE 111101 s:5 ra:5 imm:12 dx:1 101 \
!constraints { $ra > 1 && $ra != 13 && $imm <= 2032; } \
!memory { reg_plus_imm($ra, $imm << 4); }

@ format:X, book:I, page:653, Vector-Scalar_Extension, v3.0, stxvb16x # Store VSX Vector Byte*16 Indexed
STXVB16X PPC64LE 011111 s:5 ra:5 rb:5 11111 01100 sx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:654, Vector-Scalar_Extension, v2.06, stxvd2x # Store VSX Vector Doubleword*2 Indexed
STXVD2X PPC64LE 011111 s:5 ra:5 rb:5 11110 01100 sx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:655, Vector-Scalar_Extension, v3.0, stxvh8x # Store VSX Vector Halfword*8 Indexed
STXVH8X PPC64LE 011111 s:5 ra:5 rb:5 11101 01100 sx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:656, Vector-Scalar_Extension, v3.0, stxvl # Store VSX Vector with Length
STXVL PPC64LE 011111 s:5 ra:5 rb:5 01100 01101 sx:1 \
!constraints { $ra > 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg($ra); }

@ format:X, book:I, page:658, Vector-Scalar_Extension, v3.0, stxvll # Store VSX Vector with Length Left-justified
STXVLL PPC64LE 011111 s:5 ra:5 rb:5 01101 01101 sx:1 \
!constraints { $ra > 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg($ra); }

@ format:DQ, book:I, page:662, Vector-Scalar_Extension, v3.1, Skip, stxvp # Store VSX Vector Paired
STXVP PPC64LE 000110 a:22 0001

@ format:X, book:I, page:663, Vector-Scalar_Extension, v3.1, Skip, stxvpx # Store VSX Vector Paired Indexed
STXVPX PPC64LE 011111 a:15 01110011010

@ format:X, book:I, page:659, Vector-Scalar_Extension, v3.1, Skip, stxvrbx # Store VSX Vector Rightmost Byte Indexed
STXVRBX PPC64LE 011111 a:15 0010001101 rc:1

@ format:X, book:I, page:659, Vector-Scalar_Extension, v3.1, Skip, stxvrdx # Store VSX Vector Rightmost Doubleword Indexed
STXVRDX PPC64LE 011111 a:15 0011101101 rc:1

@ format:X, book:I, page:660, Vector-Scalar_Extension, v3.1, Skip, stxvrhx # Store VSX Vector Rightmost Halfword Indexed
STXVRHX PPC64LE 011111 a:15 0010101101 rc:1

@ format:X, book:I, page:660, Vector-Scalar_Extension, v3.1, Skip, stxvrwx # Store VSX Vector Rightmost Word Indexed
STXVRWX PPC64LE 011111 a:15 0011001101 rc:1

@ format:X, book:I, page:661, Vector-Scalar_Extension, v2.06, stxvw4x # Store VSX Vector Word*4 Indexed
STXVW4X PPC64LE 011111 s:5 ra:5 rb:5 11100 01100 sx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:X, book:I, page:664, Vector-Scalar_Extension, v3.0, stxvx # Store VSX Vector Indexed
STXVX PPC64LE 011111 s:5 ra:5 rb:5 01100 01100 sx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13 && $ra != $rb; } \
!memory { reg_plus_reg($ra, $rb); }

@ format:XO, book:I, page:77, Fixed-Point, PPC, SR, subf[o][.] # Subtract From
SUBF PPC64LE 011111 rt:5 ra:5 rb:5 00001010000 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
SUBFd PPC64LE 011111 rt:5 ra:5 rb:5 00001010001 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
SUBFo PPC64LE 011111 rt:5 ra:5 rb:5 10001010000 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
SUBFod PPC64LE 011111 rt:5 ra:5 rb:5 10001010001 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:XO, book:I, page:78, Fixed-Point, P1, SR, subfc[o][.] # Subtract From Carrying
SUBFC PPC64LE 011111 rt:5 ra:5 rb:5 00000010000 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
SUBFCd PPC64LE 011111 rt:5 ra:5 rb:5 00000010001 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
SUBFCo PPC64LE 011111 rt:5 ra:5 rb:5 10000010000 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
SUBFCod PPC64LE 011111 rt:5 ra:5 rb:5 10000010001 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:XO, book:I, page:78, Fixed-Point, P1, SR, subfe[o][.] # Subtract From Extended
SUBFE PPC64LE 011111 rt:5 ra:5 rb:5 00100010000 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
SUBFEd PPC64LE 011111 rt:5 ra:5 rb:5 00100010001 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
SUBFEo PPC64LE 011111 rt:5 ra:5 rb:5 10100010000 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }
SUBFEod PPC64LE 011111 rt:5 ra:5 rb:5 10100010001 \
!constraints { $rt != 1 && $ra != 1 && $rb != 1 && $rt != 13 && $ra != 13 && $rb != 13; }

@ format:D, book:I, page:77, Fixed-Point, P1, SR, subfic # Subtract From Immediate Carrying
SUBFIC PPC64LE 001000 rt:5 ra:5 imm:16 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }

@ format:XO, book:I, page:79, Fixed-Point, P1, SR, subfme[o][.] # Subtract From Minus One Extended
SUBFME PPC64LE 011111 rt:5 ra:5 0000000111010000 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }
SUBFMEd PPC64LE 011111 rt:5 ra:5 0000000111010001 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }
SUBFMEo PPC64LE 011111 rt:5 ra:5 0000010111010000 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }
SUBFMEod PPC64LE 011111 rt:5 ra:5 0000010111010001 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }

@ format:XO, book:I, page:78, Fixed-Point, P1, SR, subfze[o][.] # Subtract From Zero Extended
SUBFZE PPC64LE 011111 rt:5 ra:5 0000000110010000 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }
SUBFZEd PPC64LE 011111 rt:5 ra:5 0000000110010001 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }
SUBFZEo PPC64LE 011111 rt:5 ra:5 0000010110010000 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }
SUBFZEod PPC64LE 011111 rt:5 ra:5 0000010110010001 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }

@ format:X, book:II, page:1096, Storage_Control, P1, Skip, sync # Synchronize
SYNC PPC64LE 011111000 a:2 000000000010010101100

# TRAP instructions *******************************************************************

@ format:X, book:I, page:98, Fixed-Point, PPC, PPC64, Skip, td # Trap Doubleword
TD PPC64LE 011111 to:5 ra:5 rb:5 00010001000 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13; }

@ format:D, book:I, page:98, Fixed-Point, PPC, PPC64, Skip, tdi # Trap Doubleword Immediate
TDI PPC64LE 000010 to:5 ra:5 imm:16 \
!constraints { $ra != 1 && $ra != 13; }

@ format:X, book:III, page:1245, Storage_Control, P1, HV, _64, Skip, tlbie # TLB Invalidate Entry
TLBIE PPC64LE 011111 a:5 0 b:9 01001100100

@ format:X, book:III, page:1250, Storage_Control, v2.03, P, _64, Skip, tlbiel # TLB Invalidate Entry Local
TLBIEL PPC64LE 011111 a:5 0 b:9 01000100100

@ format:X, book:III, page:1254, Storage_Control, PPC, HV, P, Skip, tlbsync # TLB Synchronize
TLBSYNC PPC64LE 01111100000000000000010001101100

@ format:X, book:I, page:97, Fixed-Point, P1, Skip, tw # Trap Word
TW PPC64LE 011111 to:5 ra:5 rb:5 00000001000 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13; }

@ format:D, book:I, page:97, Fixed-Point, P1, Skip, twi # Trap Word Immediate
TWI PPC64LE 000011 to:5 ra:5 imm:16 \
!constraints { $ra != 1 && $ra != 13; }

@ format:XL, book:III, page:1163, Branch, v3.0C, UV, Skip, urfid # Ultravisor Return From Interrupt Doubleword
URFID PPC64LE 01001100000000000000001001100100

@ format:VX, book:I, page:383, Vector, v3.0, vabsdub # Vector Absolute Difference Unsigned Byte
VABSDUB PPC64LE 000100 vrt:5 vra:5 vrb:5 10000 000011

@ format:VX, book:I, page:383, Vector, v3.0, vabsduh # Vector Absolute Difference Unsigned Halfword
VABSDUH PPC64LE 000100 vrt:5 vra:5 vrb:5 10001 000011

@ format:VX, book:I, page:384, Vector, v3.0, vabsduw # Vector Absolute Difference Unsigned Word
VABSDUW PPC64LE 000100 vrt:5 vra:5 vrb:5 10010 000011

@ format:VX, book:I, page:335, Vector, v2.07, vaddcuq # Vector Add & write Carry Unsigned Quadword
VADDCUQ PPC64LE 000100 vrt:5 vra:5 vrb:5 00101 000000

@ format:VX, book:I, page:328, Vector, v2.03, AltiVec, vaddcuw # Vector Add & write Carry Unsigned Word
VADDCUW PPC64LE 000100 vrt:5 vra:5 vrb:5 00110000000

@ format:VA, book:I, page:335, Vector, v2.07, vaddecuq # Vector Add Extended & write Carry Unsigned Quadword
VADDECUQ PPC64LE 000100 vrt:5 vra:5 vrb:5 vrc:5 111101

@ format:VA, book:I, page:334, Vector, v2.07, vaddeuqm # Vector Add Extended Unsigned Quadword Modulo
VADDEUQM PPC64LE 000100 vrt:5 vra:5 vrb:5 vrc:5 111100

@ format:VX, book:I, page:427, Vector, v2.03, AltiVec, vaddfp # Vector Add Floating-Point
VADDFP PPC64LE 000100 vrt:5 vra:5 vrb:5 00000001010

@ format:VX, book:I, page:328, Vector, v2.03, AltiVec, vaddsbs # Vector Add Signed Byte Saturate
VADDSBS PPC64LE 000100 vrt:5 vra:5 vrb:5 01100000000

@ format:VX, book:I, page:329, Vector, v2.03, AltiVec, vaddshs # Vector Add Signed Halfword Saturate
VADDSHS PPC64LE 000100 vrt:5 vra:5 vrb:5 01101000000

@ format:VX, book:I, page:329, Vector, v2.03, AltiVec, vaddsws # Vector Add Signed Word Saturate
VADDSWS PPC64LE 000100 vrt:5 vra:5 vrb:5 01110000000

@ format:VX, book:I, page:330, Vector, v2.03, AltiVec, vaddubm # Vector Add Unsigned Byte Modulo
VADDUBM PPC64LE 000100 vrt:5 vra:5 vrb:5 00000000000

@ format:VX, book:I, page:332, Vector, v2.03, AltiVec, vaddubs # Vector Add Unsigned Byte Saturate
VADDUBS PPC64LE 000100 vrt:5 vra:5 vrb:5 01000000000

@ format:VX, book:I, page:331, Vector, v2.07, vaddudm # Vector Add Unsigned Doubleword Modulo
VADDUDM PPC64LE 000100 vrt:5 vra:5 vrb:5 00011000000

@ format:VX, book:I, page:330, Vector, v2.03, AltiVec, vadduhm # Vector Add Unsigned Halfword Modulo
VADDUHM PPC64LE 000100 vrt:5 vra:5 vrb:5 00001000000

@ format:VX, book:I, page:332, Vector, v2.03, AltiVec, vadduhs # Vector Add Unsigned Halfword Saturate
VADDUHS PPC64LE 000100 vrt:5 vra:5 vrb:5 01001000000

@ format:VX, book:I, page:334, Vector, v2.07, vadduqm # Vector Add Unsigned Quadword Modulo
VADDUQM PPC64LE 000100 vrt:5 vra:5 vrb:5 00100000000

@ format:VX, book:I, page:331, Vector, v2.03, AltiVec, vadduwm # Vector Add Unsigned Word Modulo
VADDUWM PPC64LE 000100 vrt:5 vra:5 vrb:5 00010000000

@ format:VX, book:I, page:333, Vector, v2.03, AltiVec, vadduws # Vector Add Unsigned Word Saturate
VADDUWS PPC64LE 000100 vrt:5 vra:5 vrb:5 01010000000

@ format:VX, book:I, page:407, Vector, v2.03, AltiVec, vand # Vector Logical AND
VAND PPC64LE 000100 vrt:5 vra:5 vrb:5 10000000100

@ format:VX, book:I, page:407, Vector, v2.03, AltiVec, vandc # Vector Logical AND with Complement
VANDC PPC64LE 000100 vrt:5 vra:5 vrb:5 10001000100

@ format:VX, book:I, page:380, Vector, v2.03, AltiVec, vavgsb # Vector Average Signed Byte
VAVGSB PPC64LE 000100 vrt:5 vra:5 vrb:5 10100000010

@ format:VX, book:I, page:381, Vector, v2.03, AltiVec, vavgsh # Vector Average Signed Halfword
VAVGSH PPC64LE 000100 vrt:5 vra:5 vrb:5 10101000010

@ format:VX, book:I, page:382, Vector, v2.03, AltiVec, vavgsw # Vector Average Signed Word
VAVGSW PPC64LE 000100 vrt:5 vra:5 vrb:5 10110000010

@ format:VX, book:I, page:380, Vector, v2.03, AltiVec, vavgub # Vector Average Unsigned Byte
VAVGUB PPC64LE 000100 vrt:5 vra:5 vrb:5 10000000010

@ format:VX, book:I, page:381, Vector, v2.03, AltiVec, vavguh # Vector Average Unsigned Halfword
VAVGUH PPC64LE 000100 vrt:5 vra:5 vrb:5 10001000010

@ format:VX, book:I, page:382, Vector, v2.03, AltiVec, vavguw # Vector Average Unsigned Word
VAVGUW PPC64LE 000100 vrt:5 vra:5 vrb:5 10010000010

@ format:VX, book:I, page:466, Vector, v3.0, vbpermd # Vector Bit Permute Doubleword
VBPERMD PPC64LE 000100 vrt:5 vra:5 vrb:5 10111001100

@ format:VX, book:I, page:467, Vector, v2.07, vbpermq # Vector Bit Permute Quadword
VBPERMQ PPC64LE 000100 vrt:5 vra:5 vrb:5 10101001100

@ format:VX, book:I, page:430, Vector, v2.03, AltiVec, vcfsx # Vector Convert with round to nearest From Signed Word to floating-point format
VCFSX PPC64LE 000100 vrt:5 uim:5 vrb:5 01101001010

@ format:VX, book:I, page:461, Vector, v3.1, Skip, vcfuged # Vector Centrifuge Doubleword
VCFUGED PPC64LE 000100 a:15 10101001101

@ format:VX, book:I, page:430, Vector, v2.03, AltiVec, vcfux # Vector Convert with round to nearest From Unsigned Word to floating-point format
VCFUX PPC64LE 000100 vrt:5 uim:5 vrb:5 01100001010

@ format:VX, book:I, page:440, Vector, v2.07, vcipher # Vector AES Cipher
VCIPHER PPC64LE 000100 vrt:5 vra:5 vrb:5 10100001000

@ format:VX, book:I, page:440, Vector, v2.07, vcipherlast # Vector AES Cipher Last
VCIPHERLAST PPC64LE 000100 vrt:5 vra:5 vrb:5 10100001001

@ format:VX, book:I, page:481, Vector, v3.1, Skip, vclrlb # Vector Clear Leftmost Bytes
VCLRLB PPC64LE 000100 a:15 00110001101

@ format:VX, book:I, page:481, Vector, v3.1, Skip, vclrrb # Vector Clear Rightmost Bytes
VCLRRB PPC64LE 000100 a:15 00111001101

@ format:VX, book:I, page:452, Vector, v2.07, vclzb # Vector Count Leading Zeros Byte
VCLZB PPC64LE 000100 vrt:5 00000 vrb:5 11100000010

@ format:VX, book:I, page:454, Vector, v2.07, vclzd # Vector Count Leading Zeros Doubleword
VCLZD PPC64LE 000100 vrt:5 00000 vrb:5 11111000010

@ format:VX, book:I, page:454, Vector, v3.1, Skip, vclzdm # Vector Count Leading Zeros Doubleword under bit Mask
VCLZDM PPC64LE 000100 a:15 11110000100

@ format:VX, book:I, page:452, Vector, v2.07, vclzh # Vector Count Leading Zeros Halfword
VCLZH PPC64LE 000100 vrt:5 00000 vrb:5 11101000010

@ format:VX, book:I, page:458, Vector, v3.0, vclzlsbb # Vector Count Leading Zero Least-Significant Bits Byte
VCLZLSBB PPC64LE 000100 rt:5 00000 vrb:5 11000000010 \
!constraints { $rt != 1 && $rt != 13; }

@ format:VX, book:I, page:453, Vector, v2.07, vclzw # Vector Count Leading Zeros Word
VCLZW PPC64LE 000100 vrt:5 00000 vrb:5 11110000010

@ format:VC, book:I, page:434, Vector, v2.03, AltiVec, vcmpbfp[.] # Vector Compare Bounds Floating-Point
VCMPBFP PPC64LE 000100 vrt:5 vra:5 vrb:5 01111000110
VCMPBFPd PPC64LE 000100 vrt:5 vra:5 vrb:5 11111000110

@ format:VC, book:I, page:435, Vector, v2.03, AltiVec, vcmpeqfp[.] # Vector Compare Equal Floating-Point
VCMPEQFP PPC64LE 000100 vrt:5 vra:5 vrb:5 00011000110
VCMPEQFPd PPC64LE 000100 vrt:5 vra:5 vrb:5 10011000110

@ format:VC, book:I, page:393, Vector, v2.03, AltiVec, vcmpequb[.] # Vector Compare Equal Unsigned Byte
VCMPEQUB PPC64LE 000100 vrt:5 vra:5 vrb:5 00000000110
VCMPEQUBd PPC64LE 000100 vrt:5 vra:5 vrb:5 10000000110

@ format:VC, book:I, page:396, Vector, v2.07, vcmpequd[.] # Vector Compare Equal Unsigned Doubleword
VCMPEQUD PPC64LE 000100 vrt:5 vra:5 vrb:5 00011000111
VCMPEQUDd PPC64LE 000100 vrt:5 vra:5 vrb:5 10011000111

@ format:VC, book:I, page:394, Vector, v2.03, AltiVec, vcmpequh[.] # Vector Compare Equal Unsigned Halfword
VCMPEQUH PPC64LE 000100 vrt:5 vra:5 vrb:5 00001000110
VCMPEQUHd PPC64LE 000100 vrt:5 vra:5 vrb:5 10001000110

@ format:VC, book:I, page:397, Vector, v3.1, Skip, vcmpequq[.] # Vector Compare Equal Quadword
VCMPEQUQ PPC64LE 000100 a:15 00111000111
VCMPEQUQd PPC64LE 000100 a:15 10111000111

@ format:VC, book:I, page:393, Vector, v2.03, AltiVec, vcmpequw[.] # Vector Compare Equal Unsigned Word
VCMPEQUW PPC64LE 000100 vrt:5 vra:5 vrb:5 00010000110
VCMPEQUWd PPC64LE 000100 vrt:5 vra:5 vrb:5 10010000110

@ format:VC, book:I, page:435, Vector, v2.03, AltiVec, vcmpgefp[.] # Vector Compare Greater Than or Equal Floating-Point
VCMPGEFP PPC64LE 000100 vrt:5 vra:5 vrb:5 00111000110
VCMPGEFPd PPC64LE 000100 vrt:5 vra:5 vrb:5 10111000110

@ format:VC, book:I, page:436, Vector, v2.03, AltiVec, vcmpgtfp[.] # Vector Compare Greater Than Floating-Point
VCMPGTFP PPC64LE 000100 vrt:5 vra:5 vrb:5 01011000110
VCMPGTFPd PPC64LE 000100 vrt:5 vra:5 vrb:5 11011000110

@ format:VC, book:I, page:398, Vector, v2.03, AltiVec, vcmpgtsb[.] # Vector Compare Greater Than Signed Byte
VCMPGTSB PPC64LE 000100 vrt:5 vra:5 vrb:5 01100000110
VCMPGTSBd PPC64LE 000100 vrt:5 vra:5 vrb:5 11100000110

@ format:VC, book:I, page:401, Vector, v2.07, vcmpgtsd[.] # Vector Compare Greater Than Signed Doubleword
VCMPGTSD PPC64LE 000100 vrt:5 vra:5 vrb:5 01111000111
VCMPGTSDd PPC64LE 000100 vrt:5 vra:5 vrb:5 11111000111

@ format:VC, book:I, page:399, Vector, v2.03, AltiVec, vcmpgtsh[.] # Vector Compare Greater Than Signed Halfword
VCMPGTSH PPC64LE 000100 vrt:5 vra:5 vrb:5 01101000110
VCMPGTSHd PPC64LE 000100 vrt:5 vra:5 vrb:5 11101000110

@ format:VC, book:I, page:402, Vector, v3.1, Skip, vcmpgtsq[.] # Vector Compare Greater Than Signed Quadword
VCMPGTSQ PPC64LE 000100 a:15 01110000111
VCMPGTSQd PPC64LE 000100 a:15 11110000111

@ format:VC, book:I, page:400, Vector, v2.03, AltiVec, vcmpgtsw[.] # Vector Compare Greater Than Signed Word
VCMPGTSW PPC64LE 000100 vrt:5 vra:5 vrb:5 01110000110
VCMPGTSWd PPC64LE 000100 vrt:5 vra:5 vrb:5 11110000110

@ format:VC, book:I, page:398, Vector, v2.03, AltiVec, vcmpgtub[.] # Vector Compare Greater Than Unsigned Byte
VCMPGTUB PPC64LE 000100 vrt:5 vra:5 vrb:5 01000000110
VCMPGTUBd PPC64LE 000100 vrt:5 vra:5 vrb:5 11000000110

@ format:VC, book:I, page:401, Vector, v2.07, vcmpgtud[.] # Vector Compare Greater Than Unsigned Doubleword
VCMPGTUD PPC64LE 000100 vrt:5 vra:5 vrb:5 01011000111
VCMPGTUDd PPC64LE 000100 vrt:5 vra:5 vrb:5 11011000111

@ format:VC, book:I, page:399, Vector, v2.03, AltiVec, vcmpgtuh[.] # Vector Compare Greater Than Unsigned Halfword
VCMPGTUH PPC64LE 000100 vrt:5 vra:5 vrb:5 01001000110
VCMPGTUHd PPC64LE 000100 vrt:5 vra:5 vrb:5 11001000110

@ format:VC, book:I, page:402, Vector, v3.1, Skip, vcmpgtuq[.] # Vector Compare Greater Than Unsigned Quadword
VCMPGTUQ PPC64LE 000100 a:15 01010000111
VCMPGTUQd PPC64LE 000100 a:15 11010000111

@ format:VC, book:I, page:400, Vector, v2.03, AltiVec, vcmpgtuw[.] # Vector Compare Greater Than Unsigned Word
VCMPGTUW PPC64LE 000100 vrt:5 vra:5 vrb:5 01010000110
VCMPGTUWd PPC64LE 000100 vrt:5 vra:5 vrb:5 11010000110

@ format:VC, book:I, page:403, Vector, v3.0, vcmpneb[.] # Vector Compare Not Equal Byte
VCMPNEB PPC64LE 000100 vrt:5 vra:5 vrb:5 00000000111
VCMPNEBd PPC64LE 000100 vrt:5 vra:5 vrb:5 10000000111

@ format:VC, book:I, page:404, Vector, v3.0, vcmpneh[.] # Vector Compare Not Equal Halfword
VCMPNEH PPC64LE 000100 vrt:5 vra:5 vrb:5 00001000111
VCMPNEHd PPC64LE 000100 vrt:5 vra:5 vrb:5 10001000111

@ format:VC, book:I, page:405, Vector, v3.0, vcmpnew[.] # Vector Compare Not Equal Word
VCMPNEW PPC64LE 000100 vrt:5 vra:5 vrb:5 00010000111
VCMPNEWd PPC64LE 000100 vrt:5 vra:5 vrb:5 10010000111

@ format:VC, book:I, page:403, Vector, v3.0, vcmpnezb[.] # Vector Compare Not Equal or Zero Byte
VCMPNEZB PPC64LE 000100 vrt:5 vra:5 vrb:5 00100000111
VCMPNEZBd PPC64LE 000100 vrt:5 vra:5 vrb:5 10100000111

@ format:VC, book:I, page:404, Vector, v3.0, vcmpnezh[.] # Vector Compare Not Equal or Zero Halfword
VCMPNEZH PPC64LE 000100 vrt:5 vra:5 vrb:5 00101000111
VCMPNEZHd PPC64LE 000100 vrt:5 vra:5 vrb:5 10101000111

@ format:VC, book:I, page:405, Vector, v3.0, vcmpnezw[.] # Vector Compare Not Equal or Zero Word
VCMPNEZW PPC64LE 000100 vrt:5 vra:5 vrb:5 00110000111
VCMPNEZWd PPC64LE 000100 vrt:5 vra:5 vrb:5 10110000111

@ format:VX, book:I, page:406, Vector, v3.1, Skip, vcmpsq # Vector Compare Signed Quadword
VCMPSQ PPC64LE 000100 a:3 00 b:10 00101000001

@ format:VX, book:I, page:406, Vector, v3.1, Skip, vcmpuq # Vector Compare Unsigned Quadword
VCMPUQ PPC64LE 000100 a:3 00 b:10 00100000001

@ format:VX, book:I, page:474, Vector, v3.1, Skip, vcntmbb # Vector Count Mask Bits Byte
VCNTMBB PPC64LE 000100 a:5 1100 b:6 11001000010

@ format:VX, book:I, page:475, Vector, v3.1, Skip, vcntmbd # Vector Count Mask Bits Doubleword
VCNTMBD PPC64LE 000100 a:5 1101 b:6 11001000010

@ format:VX, book:I, page:474, Vector, v3.1, Skip, vcntmbh # Vector Count Mask Bits Halfword
VCNTMBH PPC64LE 000100 a:5 1110 b:6 11001000010

@ format:VX, book:I, page:475, Vector, v3.1, Skip, vcntmbw # Vector Count Mask Bits Word
VCNTMBW PPC64LE 000100 a:5 1111 b:6 11001000010

@ format:VX, book:I, page:431, Vector, v2.03, AltiVec, vctsxs # Vector Convert with round to zero from floating-point To Signed Word format Saturate
VCTSXS PPC64LE 000100 vrt:5 uim:5 vrb:5 01111001010

@ format:VX, book:I, page:431, Vector, v2.03, AltiVec, vctuxs # Vector Convert with round to zero from floating-point To Unsigned Word format Saturate
VCTUXS PPC64LE 000100 vrt:5 uim:5 vrb:5 01110001010

@ format:VX, book:I, page:455, Vector, v3.0, vctzb # Vector Count Trailing Zeros Byte
VCTZB PPC64LE 000100 vrt:5 11100 vrb:5 11000000010

@ format:VX, book:I, page:457, Vector, v3.0, vctzd # Vector Count Trailing Zeros Doubleword
VCTZD PPC64LE 000100 vrt:5 11111 vrb:5 11000000010

@ format:VX, book:I, page:457, Vector, v3.1, Skip, vctzdm # Vector Count Trailing Zeros Doubleword under bit Mask
VCTZDM PPC64LE 000100 a:15 11111000100

@ format:VX, book:I, page:455, Vector, v3.0, vctzh # Vector Count Trailing Zeros Halfword
VCTZH PPC64LE 000100 vrt:5 11101 vrb:5 11000000010

@ format:VX, book:I, page:458, Vector, v3.0, vctzlsbb # Vector Count Trailing Zero Least-Significant Bits Byte
VCTZLSBB PPC64LE 000100 rt:5 00001 vrb:5 11000000010 \
!constraints { $rt != 1 && $rt != 13; }

@ format:VX, book:I, page:456, Vector, v3.0, vctzw # Vector Count Trailing Zeros Word
VCTZW PPC64LE 000100 vrt:5 11110 vrb:5 11000000010

@ format:VX, book:I, page:366, Vector, v3.1, Skip, vdivesd # Vector Divide Extended Signed Doubleword
VDIVESD PPC64LE 000100 a:15 01111001011

@ format:VX, book:I, page:368, Vector, v3.1, Skip, vdivesq # Vector Divide Extended Signed Quadword
VDIVESQ PPC64LE 000100 a:15 01100001011

@ format:VX, book:I, page:364, Vector, v3.1, Skip, vdivesw # Vector Divide Extended Signed Word
VDIVESW PPC64LE 000100 a:15 01110001011

@ format:VX, book:I, page:366, Vector, v3.1, Skip, vdiveud # Vector Divide Extended Unsigned Doubleword
VDIVEUD PPC64LE 000100 a:15 01011001011

@ format:VX, book:I, page:368, Vector, v3.1, Skip, vdiveuq # Vector Divide Extended Unsigned Quadword
VDIVEUQ PPC64LE 000100 a:15 01000001011

@ format:VX, book:I, page:364, Vector, v3.1, Skip, vdiveuw # Vector Divide Extended Unsigned Word
VDIVEUW PPC64LE 000100 a:15 01010001011

@ format:VX, book:I, page:365, Vector, v3.1, Skip, vdivsd # Vector Divide Signed Doubleword
VDIVSD PPC64LE 000100 a:15 00111001011

@ format:VX, book:I, page:367, Vector, v3.1, Skip, vdivsq # Vector Divide Signed Quadword
VDIVSQ PPC64LE 000100 a:15 00100001011

@ format:VX, book:I, page:363, Vector, v3.1, Skip, vdivsw # Vector Divide Signed Word
VDIVSW PPC64LE 000100 a:15 00110001011

@ format:VX, book:I, page:365, Vector, v3.1, Skip, vdivud # Vector Divide Unsigned Doubleword
VDIVUD PPC64LE 000100 a:15 00011001011

@ format:VX, book:I, page:367, Vector, v3.1, Skip, vdivuq # Vector Divide Unsigned Quadword
VDIVUQ PPC64LE 000100 a:15 00000001011

@ format:VX, book:I, page:363, Vector, v3.1, Skip, vdivuw # Vector Divide Unsigned Word
VDIVUW PPC64LE 000100 a:15 00010001011

@ format:VX, book:I, page:408, Vector, v2.07, veqv # Vector Logical Equivalence
VEQV PPC64LE 000100 vrt:5 vra:5 vrb:5 11010000100

@ format:VX, book:I, page:471, Vector, v3.1, Skip, vexpandbm # Vector Expand Byte Mask
VEXPANDBM PPC64LE 000100 a:5 00000 b:5 11001000010

@ format:VX, book:I, page:472, Vector, v3.1, Skip, vexpanddm # Vector Expand Doubleword Mask
VEXPANDDM PPC64LE 000100 a:5 00011 b:5 11001000010

@ format:VX, book:I, page:471, Vector, v3.1, Skip, vexpandhm # Vector Expand Halfword Mask
VEXPANDHM PPC64LE 000100 a:5 00001 b:5 11001000010

@ format:VX, book:I, page:473, Vector, v3.1, Skip, vexpandqm # Vector Expand Quadword Mask
VEXPANDQM PPC64LE 000100 a:5 00100 b:5 11001000010

@ format:VX, book:I, page:472, Vector, v3.1, Skip, vexpandwm # Vector Expand Word Mask
VEXPANDWM PPC64LE 000100 a:5 00010 b:5 11001000010

@ format:VX, book:I, page:437, Vector, v2.03, AltiVec, vexptefp # Vector 2 Raised to the Exponent Estimate Floating-Point
VEXPTEFP PPC64LE 000100 vrt:5 00000 vrb:5 00110001010

@ format:VA, book:I, page:317, Vector, v3.1, Skip, vextddvlx # Vector Extract Double Doubleword to VSR using GPR-specified Left-Index
VEXTDDVLX PPC64LE 000100 a:20 011110

@ format:VA, book:I, page:317, Vector, v3.1, Skip, vextddvrx # Vector Extract Double Doubleword to VSR using GPR-specified Right-Index
VEXTDDVRX PPC64LE 000100 a:20 011111

@ format:VA, book:I, page:314, Vector, v3.1, Skip, vextdubvlx # Vector Extract Double Unsigned Byte to VSR using GPR-specified Left-Index
VEXTDUBVLX PPC64LE 000100 a:20 011000

@ format:VA, book:I, page:314, Vector, v3.1, Skip, vextdubvrx # Vector Extract Double Unsigned Byte to VSR using GPR-specified Right-Index
VEXTDUBVRX PPC64LE 000100 a:20 011001

@ format:VA, book:I, page:315, Vector, v3.1, Skip, vextduhvlx # Vector Extract Double Unsigned Halfword to VSR using GPR-specified Left-Index
VEXTDUHVLX PPC64LE 000100 a:20 011010

@ format:VA, book:I, page:315, Vector, v3.1, Skip, vextduhvrx # Vector Extract Double Unsigned Halfword to VSR using GPR-specified Right-Index
VEXTDUHVRX PPC64LE 000100 a:20 011011

@ format:VA, book:I, page:316, Vector, v3.1, Skip, vextduwvlx # Vector Extract Double Unsigned Word to VSR using GPR-specified Left-Index
VEXTDUWVLX PPC64LE 000100 a:20 011100

@ format:VA, book:I, page:316, Vector, v3.1, Skip, vextduwvrx # Vector Extract Double Unsigned Word to VSR using GPR-specified Right-Index
VEXTDUWVRX PPC64LE 000100 a:20 011101

@ format:VX, book:I, page:476, Vector, v3.1, Skip, vextractbm # Vector Extract Byte Mask
VEXTRACTBM PPC64LE 000100 a:5 01000 b:5 11001000010

@ format:VX, book:I, page:310, Vector, v3.0, vextractd # Vector Extract Doubleword to VSR using immediate-specified index
VEXTRACTD PPC64LE 000100 vrt:5 0 uim:4 vrb:5 01011001101

@ format:VX, book:I, page:477, Vector, v3.1, Skip, vextractdm # Vector Extract Doubleword Mask
VEXTRACTDM PPC64LE 000100 a:5 01011 b:5 11001000010

@ format:VX, book:I, page:476, Vector, v3.1, Skip, vextracthm # Vector Extract Halfword Mask
VEXTRACTHM PPC64LE 000100 a:5 01001 b:5 11001000010

@ format:VX, book:I, page:478, Vector, v3.1, Skip, vextractqm # Vector Extract Quadword Mask
VEXTRACTQM PPC64LE 000100 a:5 01100 b:5 11001000010

@ format:VX, book:I, page:309, Vector, v3.0, vextractub # Vector Extract Unsigned Byte to VSR using immediate-specified index
VEXTRACTUB PPC64LE 000100 vrt:5 0 uim:4 vrb:5 01000001101

@ format:VX, book:I, page:309, Vector, v3.0, vextractuh # Vector Extract Unsigned Halfword to VSR using immediate-specified index
VEXTRACTUH PPC64LE 000100 vrt:5 0 uim:4 vrb:5 01001001101

@ format:VX, book:I, page:310, Vector, v3.0, vextractuw # Vector Extract Unsigned Word to VSR using immediate-specified index
VEXTRACTUW PPC64LE 000100 vrt:5 0 uim:4 vrb:5 01010001101

@ format:VX, book:I, page:477, Vector, v3.1, Skip, vextractwm # Vector Extract Word Mask
VEXTRACTWM PPC64LE 000100 a:5 01010 b:5 11001000010

@ format:VX, book:I, page:378, Vector, v3.0, vextsb2d # Vector Extend Sign Byte To Doubleword
VEXTSB2D PPC64LE 000100 vrt:5 11000 vrb:5 11000000010

@ format:VX, book:I, page:377, Vector, v3.0, vextsb2w # Vector Extend Sign Byte To Word
VEXTSB2W PPC64LE 000100 vrt:5 10000 vrb:5 11000000010

@ format:VX, book:I, page:379, Vector, v3.1, Skip, vextsd2q # Vector Extend Sign Doubleword to Quadword
VEXTSD2Q PPC64LE 000100 a:5 11011 b:5 11000000010

@ format:VX, book:I, page:378, Vector, v3.0, vextsh2d # Vector Extend Sign Halfword To Doubleword
VEXTSH2D PPC64LE 000100 vrt:5 11001 vrb:5 11000000010

@ format:VX, book:I, page:377, Vector, v3.0, vextsh2w # Vector Extend Sign Halfword To Word
VEXTSH2W PPC64LE 000100 vrt:5 10001 vrb:5 11000000010

@ format:VX, book:I, page:377, Vector, v3.0, vextsw2d # Vector Extend Sign Word To Doubleword
VEXTSW2D PPC64LE 000100 vrt:5 11010 vrb:5 11000000010

@ format:VX, book:I, page:311, Vector, v3.0, vextublx # Vector Extract Unsigned Byte to GPR using GPR-specified Left-Index
VEXTUBLX PPC64LE 000100 rt:5 ra:5 vrb:5 11000001101 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }

@ format:VX, book:I, page:311, Vector, v3.0, vextubrx # Vector Extract Unsigned Byte to GPR using GPR-specified Right-Index
VEXTUBRX PPC64LE 000100 rt:5 ra:5 vrb:5 11100001101 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }

@ format:VX, book:I, page:312, Vector, v3.0, vextuhlx # Vector Extract Unsigned Halfword to GPR using GPR-specified Left-Index
VEXTUHLX PPC64LE 000100 rt:5 ra:5 vrb:5 11001001101 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }

@ format:VX, book:I, page:312, Vector, v3.0, vextuhrx # Vector Extract Unsigned Halfword to GPR using GPR-specified Right-Index
VEXTUHRX PPC64LE 000100 rt:5 ra:5 vrb:5 11101001101 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }

@ format:VX, book:I, page:313, Vector, v3.0, vextuwlx # Vector Extract Unsigned Word to GPR using GPR-specified Left-Index
VEXTUWLX PPC64LE 000100 rt:5 ra:5 vrb:5 11010001101 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }

@ format:VX, book:I, page:313, Vector, v3.0, vextuwrx # Vector Extract Unsigned Word to GPR using GPR-specified Right-Index
VEXTUWRX PPC64LE 000100 rt:5 ra:5 vrb:5 11110001101 \
!constraints { $rt != 1 && $ra != 1 && $rt != 13 && $ra != 13; }

@ format:VX, book:I, page:450, Vector, v2.07, vgbbd # Vector Gather Bits by Bytes by Doubleword
VGBBD PPC64LE 000100 vrt:5 00000 vrb:5 10100001100

@ format:VX, book:I, page:451, Vector, v3.1, Skip, vgnb # Vector Gather every Nth Bit
VGNB PPC64LE 000100 a:5 00 b:8 10011001100

@ format:VX, book:I, page:320, Vector, v3.1, Skip, vinsblx # Vector Insert Byte from GPR using GPR-specified Left-Index
VINSBLX PPC64LE 000100 a:15 01000001111

@ format:VX, book:I, page:320, Vector, v3.1, Skip, vinsbrx # Vector Insert Byte from GPR using GPR-specified Right-Index
VINSBRX PPC64LE 000100 a:15 01100001111

@ format:VX, book:I, page:325, Vector, v3.1, Skip, vinsbvlx # Vector Insert Byte from VSR using GPR-specified Left-Index
VINSBVLX PPC64LE 000100 a:15 00000001111

@ format:VX, book:I, page:325, Vector, v3.1, Skip, vinsbvrx # Vector Insert Byte from VSR using GPR-specified Right-Index
VINSBVRX PPC64LE 000100 a:15 00100001111

@ format:VX, book:I, page:324, Vector, v3.1, Skip, vinsd # Vector Insert Doubleword from GPR using immediate-specified index
VINSD PPC64LE 000100 a:5 0 b:9 00111001111

@ format:VX, book:I, page:323, Vector, v3.1, Skip, vinsdlx # Vector Insert Doubleword from GPR using GPR-specified Left-Index
VINSDLX PPC64LE 000100 a:15 01011001111

@ format:VX, book:I, page:323, Vector, v3.1, Skip, vinsdrx # Vector Insert Doubleword from GPR using GPR-specified Right-Index
VINSDRX PPC64LE 000100 a:15 01111001111

@ format:VX, book:I, page:318, Vector, v3.0, vinsertb # Vector Insert Byte from VSR using immediate-specified index
VINSERTB PPC64LE 000100 vrt:5 0 uim:4 vrb:5 01100001101

@ format:VX, book:I, page:319, Vector, v3.0, vinsertd # Vector Insert Doubleword from VSR using immediate-specified index
VINSERTD PPC64LE 000100 vrt:5 0 uim:4 vrb:5 01111001101

@ format:VX, book:I, page:318, Vector, v3.0, vinserth # Vector Insert Halfword from VSR using immediate-specified index
VINSERTH PPC64LE 000100 vrt:5 0 uim:4 vrb:5 01101001101

@ format:VX, book:I, page:319, Vector, v3.0, vinsertw # Vector Insert Word from VSR using immediate-specified index
VINSERTW PPC64LE 000100 vrt:5 0 uim:4 vrb:5 01110001101

@ format:VX, book:I, page:321, Vector, v3.1, Skip, vinshlx # Vector Insert Halfword from GPR using GPR-specified Left-Index
VINSHLX PPC64LE 000100 a:15 01001001111

@ format:VX, book:I, page:321, Vector, v3.1, Skip, vinshrx # Vector Insert Halfword from GPR using GPR-specified Right-Index
VINSHRX PPC64LE 000100 a:15 01101001111

@ format:VX, book:I, page:326, Vector, v3.1, Skip, vinshvlx # Vector Insert Halfword from VSR using GPR-specified Left-Index
VINSHVLX PPC64LE 000100 a:15 00001001111

@ format:VX, book:I, page:326, Vector, v3.1, Skip, vinshvrx # Vector Insert Halfword from VSR using GPR-specified Right-Index
VINSHVRX PPC64LE 000100 a:15 00101001111

@ format:VX, book:I, page:324, Vector, v3.1, Skip, vinsw # Vector Insert Word from GPR using immediate-specified index
VINSW PPC64LE 000100 a:5 0 b:9 00011001111

@ format:VX, book:I, page:322, Vector, v3.1, Skip, vinswlx # Vector Insert Word from GPR using GPR-specified Left-Index
VINSWLX PPC64LE 000100 a:15 01010001111

@ format:VX, book:I, page:322, Vector, v3.1, Skip, vinswrx # Vector Insert Word from GPR using GPR-specified Right-Index
VINSWRX PPC64LE 000100 a:15 01110001111

@ format:VX, book:I, page:327, Vector, v3.1, Skip, vinswvlx # Vector Insert Word from VSR using GPR-specified Left-Index
VINSWVLX PPC64LE 000100 a:15 00010001111

@ format:VX, book:I, page:327, Vector, v3.1, Skip, vinswvrx # Vector Insert Word from VSR using GPR-specified Left-Index
VINSWVRX PPC64LE 000100 a:15 00110001111

@ format:VX, book:I, page:438, Vector, v2.03, AltiVec, vlogefp # Vector Log Base 2 Estimate Floating-Point
VLOGEFP PPC64LE 000100 vrt:5 00000 vrb:5 00111001010

@ format:VA, book:I, page:428, Vector, v2.03, AltiVec, vmaddfp # Vector Multiply-Add Floating-Point
VMADDFP PPC64LE 000100 vrt:5 vra:5 vrb:5 vrc:5 101110

@ format:VX, book:I, page:429, Vector, v2.03, AltiVec, vmaxfp # Vector Maximum Floating-Point
VMAXFP PPC64LE 000100 vrt:5 vra:5 vrb:5 10000001010

@ format:VX, book:I, page:385, Vector, v2.03, AltiVec, vmaxsb # Vector Maximum Signed Byte
VMAXSB PPC64LE 000100 vrt:5 vra:5 vrb:5 00100000010

@ format:VX, book:I, page:388, Vector, v2.07, vmaxsd # Vector Maximum Signed Doubleword
VMAXSD PPC64LE 000100 vrt:5 vra:5 vrb:5 00111000010

@ format:VX, book:I, page:386, Vector, v2.03, AltiVec, vmaxsh # Vector Maximum Signed Halfword
VMAXSH PPC64LE 000100 vrt:5 vra:5 vrb:5 00101000010

@ format:VX, book:I, page:387, Vector, v2.03, AltiVec, vmaxsw # Vector Maximum Signed Word
VMAXSW PPC64LE 000100 vrt:5 vra:5 vrb:5 00110000010

@ format:VX, book:I, page:385, Vector, v2.03, AltiVec, vmaxub # Vector Maximum Unsigned Byte
VMAXUB PPC64LE 000100 vrt:5 vra:5 vrb:5 00000000010

@ format:VX, book:I, page:388, Vector, v2.07, vmaxud # Vector Maximum Unsigned Doubleword
VMAXUD PPC64LE 000100 vrt:5 vra:5 vrb:5 00011000010

@ format:VX, book:I, page:386, Vector, v2.03, AltiVec, vmaxuh # Vector Maximum Unsigned Halfword
VMAXUH PPC64LE 000100 vrt:5 vra:5 vrb:5 00001000010

@ format:VX, book:I, page:387, Vector, v2.03, AltiVec, vmaxuw # Vector Maximum Unsigned Word
VMAXUW PPC64LE 000100 vrt:5 vra:5 vrb:5 00010000010

@ format:VA, book:I, page:356, Vector, v2.03, AltiVec, vmhaddshs # Vector Multiply-High-Add Signed Halfword Saturate
VMHADDSHS PPC64LE 000100 vrt:5 vra:5 vrb:5 vrc:5 100000

@ format:VA, book:I, page:356, Vector, v2.03, AltiVec, vmhraddshs # Vector Multiply-High-Round-Add Signed Halfword Saturate
VMHRADDSHS PPC64LE 000100 vrt:5 vra:5 vrb:5 vrc:5 100001

@ format:VX, book:I, page:429, Vector, v2.03, AltiVec, vminfp # Vector Minimum Floating-Point
VMINFP PPC64LE 000100 vrt:5 vra:5 vrb:5 10001001010

@ format:VX, book:I, page:389, Vector, v2.03, AltiVec, vminsb # Vector Minimum Signed Byte
VMINSB PPC64LE 000100 vrt:5 vra:5 vrb:5 01100000010

@ format:VX, book:I, page:392, Vector, v2.07, vminsd # Vector Minimum Signed Doubleword
VMINSD PPC64LE 000100 vrt:5 vra:5 vrb:5 01111000010

@ format:VX, book:I, page:390, Vector, v2.03, AltiVec, vminsh # Vector Minimum Signed Halfword
VMINSH PPC64LE 000100 vrt:5 vra:5 vrb:5 01101000010

@ format:VX, book:I, page:391, Vector, v2.03, AltiVec, vminsw # Vector Minimum Signed Word
VMINSW PPC64LE 000100 vrt:5 vra:5 vrb:5 01110000010

@ format:VX, book:I, page:389, Vector, v2.03, AltiVec, vminub # Vector Minimum Unsigned Byte
VMINUB PPC64LE 000100 vrt:5 vra:5 vrb:5 01000000010

@ format:VX, book:I, page:392, Vector, v2.07, vminud # Vector Minimum Unsigned Doubleword
VMINUD PPC64LE 000100 vrt:5 vra:5 vrb:5 01011000010

@ format:VX, book:I, page:390, Vector, v2.03, AltiVec, vminuh # Vector Minimum Unsigned Halfword
VMINUH PPC64LE 000100 vrt:5 vra:5 vrb:5 01001000010

@ format:VX, book:I, page:391, Vector, v2.03, AltiVec, vminuw # Vector Minimum Unsigned Word
VMINUW PPC64LE 000100 vrt:5 vra:5 vrb:5 01010000010

@ format:VA, book:I, page:357, Vector, v2.03, AltiVec, vmladduhm # Vector Multiply-Low-Add Unsigned Halfword Modulo
VMLADDUHM PPC64LE 000100 vrt:5 vra:5 vrb:5 vrc:5 100010

@ format:VX, book:I, page:370, Vector, v3.1, Skip, vmodsd # Vector Modulo Signed Doubleword
VMODSD PPC64LE 000100 a:15 11111001011

@ format:VX, book:I, page:371, Vector, v3.1, Skip, vmodsq # Vector Modulo Signed Quadword
VMODSQ PPC64LE 000100 a:15 11100001011

@ format:VX, book:I, page:369, Vector, v3.1, Skip, vmodsw # Vector Modulo Signed Word
VMODSW PPC64LE 000100 a:15 11110001011

@ format:VX, book:I, page:370, Vector, v3.1, Skip, vmodud # Vector Modulo Unsigned Doubleword
VMODUD PPC64LE 000100 a:15 11011001011

@ format:VX, book:I, page:371, Vector, v3.1, Skip, vmoduq # Vector Modulo Unsigned Quadword
VMODUQ PPC64LE 000100 a:15 11000001011

@ format:VX, book:I, page:369, Vector, v3.1, Skip, vmoduw # Vector Modulo Unsigned Word
VMODUW PPC64LE 000100 a:15 11010001011

@ format:VX, book:I, page:297, Vector, v2.07, vmrgew # Vector Merge Even Word
VMRGEW PPC64LE 000100 vrt:5 vra:5 vrb:5 11110001100

@ format:VX, book:I, page:294, Vector, v2.03, AltiVec, vmrghb # Vector Merge High Byte
VMRGHB PPC64LE 000100 vrt:5 vra:5 vrb:5 00000001100

@ format:VX, book:I, page:295, Vector, v2.03, AltiVec, vmrghh # Vector Merge High Halfword
VMRGHH PPC64LE 000100 vrt:5 vra:5 vrb:5 00001001100

@ format:VX, book:I, page:296, Vector, v2.03, AltiVec, vmrghw # Vector Merge High Word
VMRGHW PPC64LE 000100 vrt:5 vra:5 vrb:5 00010001100

@ format:VX, book:I, page:294, Vector, v2.03, AltiVec, vmrglb # Vector Merge Low Byte
VMRGLB PPC64LE 000100 vrt:5 vra:5 vrb:5 00100001100

@ format:VX, book:I, page:295, Vector, v2.03, AltiVec, vmrglh # Vector Merge Low Halfword
VMRGLH PPC64LE 000100 vrt:5 vra:5 vrb:5 00101001100

@ format:VX, book:I, page:296, Vector, v2.03, AltiVec, vmrglw # Vector Merge Low Word
VMRGLW PPC64LE 000100 vrt:5 vra:5 vrb:5 00110001100

@ format:VX, book:I, page:297, Vector, v2.07, vmrgow # Vector Merge Odd Word
VMRGOW PPC64LE 000100 vrt:5 vra:5 vrb:5 11010001100

@ format:VA, book:I, page:362, Vector, v3.1, Skip, vmsumcud # Vector Multiply-Sum & write Carry-out Unsigned Doubleword
VMSUMCUD PPC64LE 000100 a:20 010111

@ format:VA, book:I, page:358, Vector, v2.03, AltiVec, vmsummbm # Vector Multiply-Sum Mixed Byte Modulo
VMSUMMBM PPC64LE 000100 vrt:5 vra:5 vrb:5 vrc:5 100101

@ format:VA, book:I, page:358, Vector, v2.03, AltiVec, vmsumshm # Vector Multiply-Sum Signed Halfword Modulo
VMSUMSHM PPC64LE 000100 vrt:5 vra:5 vrb:5 vrc:5 101000

@ format:VA, book:I, page:359, Vector, v2.03, AltiVec, vmsumshs # Vector Multiply-Sum Signed Halfword Saturate
VMSUMSHS PPC64LE 000100 vrt:5 vra:5 vrb:5 vrc:5 101001

@ format:VA, book:I, page:357, Vector, v2.03, AltiVec, vmsumubm # Vector Multiply-Sum Unsigned Byte Modulo
VMSUMUBM PPC64LE 000100 vrt:5 vra:5 vrb:5 vrc:5 100100

@ format:VA, book:I, page:361, Vector, v3.0B, Skip, vmsumudm # Vector Multiply-Sum Unsigned Doubleword Modulo
VMSUMUDM PPC64LE 000100 a:20 100011

@ format:VA, book:I, page:359, Vector, v2.03, AltiVec, vmsumuhm # Vector Multiply-Sum Unsigned Halfword Modulo
VMSUMUHM PPC64LE 000100 vrt:5 vra:5 vrb:5 vrc:5 100110

@ format:VA, book:I, page:360, Vector, v2.03, AltiVec, vmsumuhs # Vector Multiply-Sum Unsigned Halfword Saturate
VMSUMUHS PPC64LE 000100 vrt:5 vra:5 vrb:5 vrc:5 100111

@ format:VX, book:I, page:492, Vector, v3.0, vmul10cuq # Vector Multiply-by-10 & write Carry-out Unsigned Quadword
VMUL10CUQ PPC64LE 000100 vrt:5 vra:5 0000000000000001

@ format:VX, book:I, page:493, Vector, v3.0, vmul10ecuq # Vector Multiply-by-10 Extended & write Carry-out Unsigned Quadword
VMUL10ECUQ PPC64LE 000100 vrt:5 vra:5 vrb:5 00001000001

@ format:VX, book:I, page:493, Vector, v3.0, vmul10euq # Vector Multiply-by-10 Extended Unsigned Quadword
VMUL10EUQ PPC64LE 000100 vrt:5 vra:5 vrb:5 01001000001

@ format:VX, book:I, page:492, Vector, v3.0, vmul10uq # Vector Multiply-by-10 Unsigned Quadword
VMUL10UQ PPC64LE 000100 vrt:5 vra:5 0000001000000001

@ format:VX, book:I, page:344, Vector, v2.03, AltiVec, vmulesb # Vector Multiply Even Signed Byte
VMULESB PPC64LE 000100 vrt:5 vra:5 vrb:5 01100001000

@ format:VX, book:I, page:351, Vector, v3.1, Skip, vmulesd # Vector Multiply Even Signed Doubleword
VMULESD PPC64LE 000100 a:15 01111001000

@ format:VX, book:I, page:346, Vector, v2.03, AltiVec, vmulesh # Vector Multiply Even Signed Halfword
VMULESH PPC64LE 000100 vrt:5 vra:5 vrb:5 01101001000

@ format:VX, book:I, page:348, Vector, v2.07, vmulesw # Vector Multiply Even Signed Word
VMULESW PPC64LE 000100 vrt:5 vra:5 vrb:5 01110001000

@ format:VX, book:I, page:345, Vector, v2.03, AltiVec, vmuleub # Vector Multiply Even Unsigned Byte
VMULEUB PPC64LE 000100 vrt:5 vra:5 vrb:5 01000001000

@ format:VX, book:I, page:350, Vector, v3.1, Skip, vmuleud # Vector Multiply Even Unsigned Doubleword
VMULEUD PPC64LE 000100 a:15 01011001000

@ format:VX, book:I, page:347, Vector, v2.03, AltiVec, vmuleuh # Vector Multiply Even Unsigned Halfword
VMULEUH PPC64LE 000100 vrt:5 vra:5 vrb:5 01001001000

@ format:VX, book:I, page:349, Vector, v2.07, vmuleuw # Vector Multiply Even Unsigned Word
VMULEUW PPC64LE 000100 vrt:5 vra:5 vrb:5 01010001000

@ format:VX, book:I, page:354, Vector, v3.1, Skip, vmulhsd # Vector Multiply High Signed Doubleword
VMULHSD PPC64LE 000100 a:15 01111001001

@ format:VX, book:I, page:352, Vector, v3.1, Skip, vmulhsw # Vector Multiply High Signed Word
VMULHSW PPC64LE 000100 a:15 01110001001

@ format:VX, book:I, page:354, Vector, v3.1, Skip, vmulhud # Vector Multiply High Unsigned Doubleword
VMULHUD PPC64LE 000100 a:15 01011001001

@ format:VX, book:I, page:353, Vector, v3.1, Skip, vmulhuw # Vector Multiply High Unsigned Word
VMULHUW PPC64LE 000100 a:15 01010001001

@ format:VX, book:I, page:355, Vector, v3.1, Skip, vmulld # Vector Multiply Low Doubleword
VMULLD PPC64LE 000100 a:15 00111001001

@ format:VX, book:I, page:344, Vector, v2.03, AltiVec, vmulosb # Vector Multiply Odd Signed Byte
VMULOSB PPC64LE 000100 vrt:5 vra:5 vrb:5 00100001000

@ format:VX, book:I, page:351, Vector, v3.1, Skip, vmulosd # Vector Multiply Odd Signed Doubleword
VMULOSD PPC64LE 000100 a:15 00111001000

@ format:VX, book:I, page:346, Vector, v2.03, AltiVec, vmulosh # Vector Multiply Odd Signed Halfword
VMULOSH PPC64LE 000100 vrt:5 vra:5 vrb:5 00101001000

@ format:VX, book:I, page:348, Vector, v2.07, vmulosw # Vector Multiply Odd Signed Word
VMULOSW PPC64LE 000100 vrt:5 vra:5 vrb:5 00110001000

@ format:VX, book:I, page:345, Vector, v2.03, AltiVec, vmuloub # Vector Multiply Odd Unsigned Byte
VMULOUB PPC64LE 000100 vrt:5 vra:5 vrb:5 00000001000

@ format:VX, book:I, page:350, Vector, v3.1, Skip, vmuloud # Vector Multiply Odd Unsigned Doubleword
VMULOUD PPC64LE 000100 a:15 00011001000

@ format:VX, book:I, page:347, Vector, v2.03, AltiVec, vmulouh # Vector Multiply Odd Unsigned Halfword
VMULOUH PPC64LE 000100 vrt:5 vra:5 vrb:5 00001001000

@ format:VX, book:I, page:349, Vector, v2.07, vmulouw # Vector Multiply Odd Unsigned Word
VMULOUW PPC64LE 000100 vrt:5 vra:5 vrb:5 00010001000

@ format:VX, book:I, page:352, Vector, v2.07, vmuluwm # Vector Multiply Unsigned Word Modulo
VMULUWM PPC64LE 000100 vrt:5 vra:5 vrb:5 00010001001

@ format:VX, book:I, page:408, Vector, v2.07, vnand # Vector Logical NAND
VNAND PPC64LE 000100 vrt:5 vra:5 vrb:5 10110000100

@ format:VX, book:I, page:441, Vector, v2.07, vncipher # Vector AES Inverse Cipher
VNCIPHER PPC64LE 000100 vrt:5 vra:5 vrb:5 10101001000

@ format:VX, book:I, page:441, Vector, v2.07, vncipherlast # Vector AES Inverse Cipher Last
VNCIPHERLAST PPC64LE 000100 vrt:5 vra:5 vrb:5 10101001001

@ format:VX, book:I, page:376, Vector, v3.0, vnegd # Vector Negate Doubleword
VNEGD PPC64LE 000100 vrt:5 00111 vrb:5 11000000010

@ format:VX, book:I, page:376, Vector, v3.0, vnegw # Vector Negate Word
VNEGW PPC64LE 000100 vrt:5 00110 vrb:5 11000000010

@ format:VA, book:I, page:428, Vector, v2.03, AltiVec, vnmsubfp # Vector Negative Multiply-Subtract Floating-Point
VNMSUBFP PPC64LE 000100 vrt:5 vra:5 vrb:5 vrc:5 101111

@ format:VX, book:I, page:408, Vector, v2.03, AltiVec, vnor # Vector Logical NOR
VNOR PPC64LE 000100 vrt:5 vra:5 vrb:5 10100000100

@ format:VX, book:I, page:408, Vector, v2.03, AltiVec, vor # Vector Logical OR
VOR PPC64LE 000100 vrt:5 vra:5 vrb:5 10010000100

@ format:VX, book:I, page:408, Vector, v2.07, vorc # Vector Logical OR with Complement
VORC PPC64LE 000100 vrt:5 vra:5 vrb:5 10101000100

@ format:VX, book:I, page:459, Vector, v3.1, Skip, vpdepd # Vector Parallel Bits Deposit Doubleword
VPDEPD PPC64LE 000100 a:15 10111001101

@ format:VA, book:I, page:301, Vector, v2.03, AltiVec, vperm # Vector Permute
VPERM PPC64LE 000100 vrt:5 vra:5 vrb:5 vrc:5 101011

@ format:VA, book:I, page:301, Vector, v3.0, vpermr # Vector Permute Right-indexed
VPERMR PPC64LE 000100 vrt:5 vra:5 vrb:5 vrc:5 111011

@ format:VA, book:I, page:449, Vector, v2.07, vpermxor # Vector Permute & Exclusive-OR
VPERMXOR PPC64LE 000100 vrt:5 vra:5 vrb:5 vrc:5 101101

@ format:VX, book:I, page:460, Vector, v3.1, Skip, vpextd # Vector Parallel Bits Extract Doubleword
VPEXTD PPC64LE 000100 a:15 10110001101

@ format:VX, book:I, page:283, Vector, v2.03, AltiVec, vpkpx # Vector Pack Pixel
VPKPX PPC64LE 000100 vrt:5 vra:5 vrb:5 01100001110

@ format:VX, book:I, page:286, Vector, v2.07, vpksdss # Vector Pack Signed Doubleword Signed Saturate
VPKSDSS PPC64LE 000100 vrt:5 vra:5 vrb:5 10111001110

@ format:VX, book:I, page:286, Vector, v2.07, vpksdus # Vector Pack Signed Doubleword Unsigned Saturate
VPKSDUS PPC64LE 000100 vrt:5 vra:5 vrb:5 10101001110

@ format:VX, book:I, page:284, Vector, v2.03, AltiVec, vpkshss # Vector Pack Signed Halfword Signed Saturate
VPKSHSS PPC64LE 000100 vrt:5 vra:5 vrb:5 00110001110

@ format:VX, book:I, page:284, Vector, v2.03, AltiVec, vpkshus # Vector Pack Signed Halfword Unsigned Saturate
VPKSHUS PPC64LE 000100 vrt:5 vra:5 vrb:5 00100001110

@ format:VX, book:I, page:285, Vector, v2.03, AltiVec, vpkswss # Vector Pack Signed Word Signed Saturate
VPKSWSS PPC64LE 000100 vrt:5 vra:5 vrb:5 00111001110

@ format:VX, book:I, page:285, Vector, v2.03, AltiVec, vpkswus # Vector Pack Signed Word Unsigned Saturate
VPKSWUS PPC64LE 000100 vrt:5 vra:5 vrb:5 00101001110

@ format:VX, book:I, page:289, Vector, v2.07, vpkudum # Vector Pack Unsigned Doubleword Unsigned Modulo
VPKUDUM PPC64LE 000100 vrt:5 vra:5 vrb:5 10001001110

@ format:VX, book:I, page:289, Vector, v2.07, vpkudus # Vector Pack Unsigned Doubleword Unsigned Saturate
VPKUDUS PPC64LE 000100 vrt:5 vra:5 vrb:5 10011001110

@ format:VX, book:I, page:287, Vector, v2.03, AltiVec, vpkuhum # Vector Pack Unsigned Halfword Unsigned Modulo
VPKUHUM PPC64LE 000100 vrt:5 vra:5 vrb:5 00000001110

@ format:VX, book:I, page:287, Vector, v2.03, AltiVec, vpkuhus # Vector Pack Unsigned Halfword Unsigned Saturate
VPKUHUS PPC64LE 000100 vrt:5 vra:5 vrb:5 00010001110

@ format:VX, book:I, page:288, Vector, v2.03, AltiVec, vpkuwum # Vector Pack Unsigned Word Unsigned Modulo
VPKUWUM PPC64LE 000100 vrt:5 vra:5 vrb:5 00001001110

@ format:VX, book:I, page:288, Vector, v2.03, AltiVec, vpkuwus # Vector Pack Unsigned Word Unsigned Saturate
VPKUWUS PPC64LE 000100 vrt:5 vra:5 vrb:5 00011001110

@ format:VX, book:I, page:445, Vector, v2.07, vpmsumb # Vector Polynomial Multiply-Sum Byte
VPMSUMB PPC64LE 000100 vrt:5 vra:5 vrb:5 10000001000

@ format:VX, book:I, page:448, Vector, v2.07, vpmsumd # Vector Polynomial Multiply-Sum Doubleword
VPMSUMD PPC64LE 000100 vrt:5 vra:5 vrb:5 10011001000

@ format:VX, book:I, page:446, Vector, v2.07, vpmsumh # Vector Polynomial Multiply-Sum Halfword
VPMSUMH PPC64LE 000100 vrt:5 vra:5 vrb:5 10001001000

@ format:VX, book:I, page:447, Vector, v2.07, vpmsumw # Vector Polynomial Multiply-Sum Word
VPMSUMW PPC64LE 000100 vrt:5 vra:5 vrb:5 10010001000

@ format:VX, book:I, page:462, Vector, v2.07, vpopcntb # Vector Population Count Byte
VPOPCNTB PPC64LE 000100 vrt:5 00000 vrb:5 11100000011

@ format:VX, book:I, page:463, Vector, v2.07, vpopcntd # Vector Population Count Doubleword
VPOPCNTD PPC64LE 000100 vrt:5 00000 vrb:5 11111000011

@ format:VX, book:I, page:462, Vector, v2.07, vpopcnth # Vector Population Count Halfword
VPOPCNTH PPC64LE 000100 vrt:5 00000 vrb:5 11101000011

@ format:VX, book:I, page:463, Vector, v2.07, vpopcntw # Vector Population Count Word
VPOPCNTW PPC64LE 000100 vrt:5 00000 vrb:5 11110000011

@ format:VX, book:I, page:464, Vector, v3.0, vprtybd # Vector Parity Byte Doubleword
VPRTYBD PPC64LE 000100 vrt:5 01001 vrt:5 11000000010

@ format:VX, book:I, page:465, Vector, v3.0, vprtybq # Vector Parity Byte Quadword
VPRTYBQ PPC64LE 000100 vrt:5 01010 vrt:5 11000000010

@ format:VX, book:I, page:464, Vector, v3.0, vprtybw # Vector Parity Byte Word
VPRTYBW PPC64LE 000100 vrt:5 01000 vrt:5 11000000010

@ format:VX, book:I, page:439, Vector, v2.03, AltiVec, vrefp # Vector Reciprocal Estimate Floating-Point
VREFP PPC64LE 000100 vrt:5 00000 vrt:5 00100001010

@ format:VX, book:I, page:432, Vector, v2.03, AltiVec, vrfim # Vector Round to Floating-Point Integer toward -Infinity
VRFIM PPC64LE 000100 vrt:5 00000 vrt:5 01011001010

@ format:VX, book:I, page:432, Vector, v2.03, AltiVec, vrfin # Vector Round to Floating-Point Integer Nearest
VRFIN PPC64LE 000100 vrt:5 00000 vrt:5 01000001010

@ format:VX, book:I, page:433, Vector, v2.03, AltiVec, vrfip # Vector Round to Floating-Point Integer toward +Infinity
VRFIP PPC64LE 000100 vrt:5 00000 vrt:5 01010001010

@ format:VX, book:I, page:433, Vector, v2.03, AltiVec, vrfiz # Vector Round to Floating-Point Integer toward Zero
VRFIZ PPC64LE 000100 vrt:5 00000 vrt:5 01001001010

@ format:VX, book:I, page:409, Vector, v2.03, AltiVec, vrlb # Vector Rotate Left Byte
VRLB PPC64LE 000100 vrt:5 vra:5 vrb:5 00000000100

@ format:VX, book:I, page:410, Vector, v2.07, vrld # Vector Rotate Left Doubleword
VRLD PPC64LE 000100 vrt:5 vra:5 vrb:5 00011000100

@ format:VX, book:I, page:416, Vector, v3.0, vrldmi # Vector Rotate Left Doubleword then Mask Insert
VRLDMI PPC64LE 000100 vrt:5 vra:5 vrb:5 00011000101

@ format:VX, book:I, page:413, Vector, v3.0, vrldnm # Vector Rotate Left Doubleword then AND with Mask
VRLDNM PPC64LE 000100 vrt:5 vra:5 vrb:5 00111000101

@ format:VX, book:I, page:409, Vector, v2.03, AltiVec, vrlh # Vector Rotate Left Halfword
VRLH PPC64LE 000100 vrt:5 vra:5 vrb:5 00001000100

@ format:VX, book:I, page:410, Vector, v3.1, Skip, vrlq # Vector Rotate Left Quadword
VRLQ PPC64LE 000100 a:15 00000000101

@ format:VX, book:I, page:417, Vector, v3.1, Skip, vrlqmi # Vector Rotate Left Quadword then Mask Insert
VRLQMI PPC64LE 000100 a:15 00001000101

@ format:VX, book:I, page:414, Vector, v3.1, Skip, vrlqnm # Vector Rotate Left Quadword then AND with Mask
VRLQNM PPC64LE 000100 a:15 00101000101

@ format:VX, book:I, page:409, Vector, v2.03, AltiVec, vrlw # Vector Rotate Left Word
VRLW PPC64LE 000100 vrt:5 vra:5 vrb:5 00010000100

@ format:VX, book:I, page:415, Vector, v3.0, vrlwmi # Vector Rotate Left Word then Mask Insert
VRLWMI PPC64LE 000100 vrt:5 vra:5 vrb:5 00010000101

@ format:VX, book:I, page:412, Vector, v3.0, vrlwnm # Vector Rotate Left Word then AND with Mask
VRLWNM PPC64LE 000100 vrt:5 vra:5 vrb:5 00110000101

@ format:VX, book:I, page:439, Vector, v2.03, AltiVec, vrsqrtefp # Vector Reciprocal Square Root Estimate Floating-Point
VRSQRTEFP PPC64LE 000100 vrt:5 00000 vrb:5 00101001010

@ format:VX, book:I, page:442, Vector, v2.07, vsbox # Vector AES SubBytes
VSBOX PPC64LE 000100 vrt:5 vra:5 0000010111001000

@ format:VA, book:I, page:302, Vector, v2.03, AltiVec, vsel # Vector Select
VSEL PPC64LE 000100 vrt:5 vra:5 vrb:5 vrc:5 101010

@ format:VX, book:I, page:443, Vector, v2.07, vshasigmad # Vector SHA-512 Sigma Doubleword
VSHASIGMAD PPC64LE 000100 vrt:5 vra:5 vrb:5 11011000010

@ format:VX, book:I, page:444, Vector, v2.07, vshasigmaw # Vector SHA-256 Sigma Word
VSHASIGMAW PPC64LE 000100 vrt:5 vra:5 vrb:5 11010000010

@ format:VX, book:I, page:305, Vector, v2.03, AltiVec, vsl # Vector Shift Left
VSL PPC64LE 000100 vrt:5 vra:5 vrb:5 00111000100

@ format:VX, book:I, page:418, Vector, v2.03, AltiVec, vslb # Vector Shift Left Byte
VSLB PPC64LE 000100 vrt:5 vra:5 vrb:5 00100000100

@ format:VX, book:I, page:419, Vector, v2.07, vsld # Vector Shift Left Doubleword
VSLD PPC64LE 000100 vrt:5 vra:5 vrb:5 10111000100

@ format:VN, book:I, page:303, Vector, v3.1, Skip, vsldbi # Vector Shift Left Double by Bit Immediate
VSLDBI PPC64LE 000100 a:15 00 b:3 010110

@ format:VA, book:I, page:303, Vector, v2.03, AltiVec, vsldoi # Vector Shift Left Double by Octet Immediate
VSLDOI PPC64LE 000100 vrt:5 vra:5 vrb:5 0 shb:4 101100

@ format:VX, book:I, page:418, Vector, v2.03, AltiVec, vslh # Vector Shift Left Halfword
VSLH PPC64LE 000100 vrt:5 vra:5 vrb:5 00101000100

@ format:VX, book:I, page:306, Vector, v2.03, AltiVec, vslo # Vector Shift Left by Octet
VSLO PPC64LE 000100 vrt:5 vra:5 vrb:5 10000001100

@ format:VX, book:I, page:420, Vector, v3.1, Skip, vslq # Vector Shift Left Quadword
VSLQ PPC64LE 000100 a:15 00100000101

@ format:VX, book:I, page:307, Vector, v3.0, vslv # Vector Shift Left Variable
VSLV PPC64LE 000100 vrt:5 vra:5 vrb:5 11101000100

@ format:VX, book:I, page:419, Vector, v2.03, AltiVec, vslw # Vector Shift Left Word
VSLW PPC64LE 000100 vrt:5 vra:5 vrb:5 00110000100

@ format:VX, book:I, page:298, Vector, v2.03, AltiVec, vspltb # Vector Splat Byte
VSPLTB PPC64LE 000100 vrt:5 0 uim:4 vrb:5 01000001100

@ format:VX, book:I, page:298, Vector, v2.03, AltiVec, vsplth # Vector Splat Halfword
VSPLTH PPC64LE 000100 vrt:5 00 uim:3 vrb:5 01001001100

@ format:VX, book:I, page:300, Vector, v2.03, AltiVec, vspltisb # Vector Splat Immediate Signed Byte
VSPLTISB PPC64LE 000100 vrt:5 sim:5 0000001100001100

@ format:VX, book:I, page:300, Vector, v2.03, AltiVec, vspltish # Vector Splat Immediate Signed Halfword
VSPLTISH PPC64LE 000100 vrt:5 sim:5 0000001101001100

@ format:VX, book:I, page:300, Vector, v2.03, AltiVec, vspltisw # Vector Splat Immediate Signed Word
VSPLTISW PPC64LE 000100 vrt:5 sim:5 0000001110001100

@ format:VX, book:I, page:298, Vector, v2.03, AltiVec, vspltw # Vector Splat Word
VSPLTW PPC64LE 000100 vrt:5 000 uim:2 vrb:5 01010001100

@ format:VX, book:I, page:305, Vector, v2.03, AltiVec, vsr # Vector Shift Right
VSR PPC64LE 000100 vrt:5 vra:5 vrb:5 01011000100

@ format:VX, book:I, page:424, Vector, v2.03, AltiVec, vsrab # Vector Shift Right Algebraic Byte
VSRAB PPC64LE 000100 vrt:5 vra:5 vrb:5 01100000100

@ format:VX, book:I, page:425, Vector, v2.07, vsrad # Vector Shift Right Algebraic Doubleword
VSRAD PPC64LE 000100 vrt:5 vra:5 vrb:5 01111000100

@ format:VX, book:I, page:424, Vector, v2.03, AltiVec, vsrah # Vector Shift Right Algebraic Halfword
VSRAH PPC64LE 000100 vrt:5 vra:5 vrb:5 01101000100

@ format:VX, book:I, page:426, Vector, v3.1, Skip, vsraq # Vector Shift Right Algebraic Quadword
VSRAQ PPC64LE 000100 a:15 01100000101

@ format:VX, book:I, page:425, Vector, v2.03, AltiVec, vsraw # Vector Shift Right Algebraic Word
VSRAW PPC64LE 000100 vrt:5 vra:5 vrb:5 01110000100

@ format:VX, book:I, page:421, Vector, v2.03, AltiVec, vsrb # Vector Shift Right Byte
VSRB PPC64LE 000100 vrt:5 vra:5 vrb:5 01000000100

@ format:VX, book:I, page:422, Vector, v2.07, vsrd # Vector Shift Right Doubleword
VSRD PPC64LE 000100 vrt:5 vra:5 vrb:5 11011000100

@ format:VN, book:I, page:304, Vector, v3.1, Skip, vsrdbi # Vector Shift Right Double by Bit Immediate
VSRDBI PPC64LE 000100 a:15 01 b:3 010110

@ format:VX, book:I, page:421, Vector, v2.03, AltiVec, vsrh # Vector Shift Right Halfword
VSRH PPC64LE 000100 vrt:5 vra:5 vrb:5 01001000100

@ format:VX, book:I, page:306, Vector, v2.03, AltiVec, vsro # Vector Shift Right by Octet
VSRO PPC64LE 000100 vrt:5 vra:5 vrb:5 10001001100

@ format:VX, book:I, page:423, Vector, v3.1, Skip, vsrq # Vector Shift Right Quadword
VSRQ PPC64LE 000100 a:15 01000000101

@ format:VX, book:I, page:307, Vector, v3.0, vsrv # Vector Shift Right Variable
VSRV PPC64LE 000100 vrt:5 vra:5 vrb:5 11100000100

@ format:VX, book:I, page:422, Vector, v2.03, AltiVec, vsrw # Vector Shift Right Word
VSRW PPC64LE 000100 vrt:5 vra:5 vrb:5 01010000100

@ format:VX, book:I, page:479, Vector, v3.1, Skip, vstribl[.] # Vector String Isolate Byte Left-justified
VSTRIBL PPC64LE 000100 a:5 00000 b:5 00000001101
VSTRIBLd PPC64LE 000100 a:5 00000 b:5 10000001101

@ format:VX, book:I, page:480, Vector, v3.1, Skip, vstribr[.] # Vector String Isolate Byte Right-justified
VSTRIBR PPC64LE 000100 a:5 00001 b:5 00000001101
VSTRIBRd PPC64LE 000100 a:5 00001 b:5 10000001101

@ format:VX, book:I, page:480, Vector, v3.1, Skip, vstrihl[.] # Vector String Isolate Halfword Left-justified
VSTRIHL PPC64LE 000100 a:5 00010 b:5 00000001101
VSTRIHLd PPC64LE 000100 a:5 00010 b:5 10000001101

@ format:VX, book:I, page:479, Vector, v3.1, Skip, vstrihr[.] # Vector String Isolate Halfword Right-justified
VSTRIHR PPC64LE 000100 a:5 00011 b:5 00000001101
VSTRIHRd PPC64LE 000100 a:5 00011 b:5 10000001101

@ format:VX, book:I, page:343, Vector, v2.07, vsubcuq # Vector Subtract & write Carry-out Unsigned Quadword
VSUBCUQ PPC64LE 000100 vrt:5 vra:5 vrb:5 10101000000

@ format:VX, book:I, page:336, Vector, v2.03, AltiVec, vsubcuw # Vector Subtract & Write Carry-out Unsigned Word
VSUBCUW PPC64LE 000100 vrt:5 vra:5 vrb:5 10110000000

@ format:VA, book:I, page:343, Vector, v2.07, vsubecuq # Vector Subtract Extended & write Carry-out Unsigned Quadword
VSUBECUQ PPC64LE 000100 vrt:5 vra:5 vrb:5 vrc:5 111111

@ format:VA, book:I, page:342, Vector, v2.07, vsubeuqm # Vector Subtract Extended Unsigned Quadword Modulo
VSUBEUQM PPC64LE 000100 vrt:5 vra:5 vrb:5 vrc:5 111110

@ format:VX, book:I, page:427, Vector, v2.03, AltiVec, vsubfp # Vector Subtract Floating-Point
VSUBFP PPC64LE 000100 vrt:5 vra:5 vrb:5 00001001010

@ format:VX, book:I, page:336, Vector, v2.03, AltiVec, vsubsbs # Vector Subtract Signed Byte Saturate
VSUBSBS PPC64LE 000100 vrt:5 vra:5 vrb:5 11100000000

@ format:VX, book:I, page:337, Vector, v2.03, AltiVec, vsubshs # Vector Subtract Signed Halfword Saturate
VSUBSHS PPC64LE 000100 vrt:5 vra:5 vrb:5 11101000000

@ format:VX, book:I, page:337, Vector, v2.03, AltiVec, vsubsws # Vector Subtract Signed Word Saturate
VSUBSWS PPC64LE 000100 vrt:5 vra:5 vrb:5 11110000000

@ format:VX, book:I, page:338, Vector, v2.03, AltiVec, vsububm # Vector Subtract Unsigned Byte Modulo
VSUBUBM PPC64LE 000100 vrt:5 vra:5 vrb:5 10000000000

@ format:VX, book:I, page:340, Vector, v2.03, AltiVec, vsububs # Vector Subtract Unsigned Byte Saturate
VSUBUBS PPC64LE 000100 vrt:5 vra:5 vrb:5 11000000000

@ format:VX, book:I, page:339, Vector, v2.07, vsubudm # Vector Subtract Unsigned Doubleword Modulo
VSUBUDM PPC64LE 000100 vrt:5 vra:5 vrb:5 10011000000

@ format:VX, book:I, page:338, Vector, v2.03, AltiVec, vsubuhm # Vector Subtract Unsigned Halfword Modulo
VSUBUHM PPC64LE 000100 vrt:5 vra:5 vrb:5 10001000000

@ format:VX, book:I, page:340, Vector, v2.03, AltiVec, vsubuhs # Vector Subtract Unsigned Halfword Saturate
VSUBUHS PPC64LE 000100 vrt:5 vra:5 vrb:5 11001000000

@ format:VX, book:I, page:342, Vector, v2.07, vsubuqm # Vector Subtract Unsigned Quadword Modulo
VSUBUQM PPC64LE 000100 vrt:5 vra:5 vrb:5 10100000000

@ format:VX, book:I, page:339, Vector, v2.03, AltiVec, vsubuwm # Vector Subtract Unsigned Word Modulo
VSUBUWM PPC64LE 000100 vrt:5 vra:5 vrb:5 10010000000

@ format:VX, book:I, page:341, Vector, v2.03, AltiVec, vsubuws # Vector Subtract Unsigned Word Saturate
VSUBUWS PPC64LE 000100 vrt:5 vra:5 vrb:5 11010000000

@ format:VX, book:I, page:373, Vector, v2.03, AltiVec, vsum2sws # Vector Sum across Half Signed Word Saturate
VSUM2SWS PPC64LE 000100 vrt:5 vra:5 vrb:5 11010001000

@ format:VX, book:I, page:374, Vector, v2.03, AltiVec, vsum4sbs # Vector Sum across Quarter Signed Byte Saturate
VSUM4SBS PPC64LE 000100 vrt:5 vra:5 vrb:5 11100001000

@ format:VX, book:I, page:374, Vector, v2.03, AltiVec, vsum4shs # Vector Sum across Quarter Signed Halfword Saturate
VSUM4SHS PPC64LE 000100 vrt:5 vra:5 vrb:5 11001001000

@ format:VX, book:I, page:375, Vector, v2.03, AltiVec, vsum4ubs # Vector Sum across Quarter Unsigned Byte Saturate
VSUM4UBS PPC64LE 000100 vrt:5 vra:5 vrb:5 11000001000

@ format:VX, book:I, page:372, Vector, v2.03, AltiVec, vsumsws # Vector Sum across Signed Word Saturate
VSUMSWS PPC64LE 000100 vrt:5 vra:5 vrb:5 11110001000

@ format:VX, book:I, page:293, Vector, v2.03, AltiVec, vupkhpx # Vector Unpack High Pixel
VUPKHPX PPC64LE 000100 vrt:5 00000 vrb:5 01101001110

@ format:VX, book:I, page:290, Vector, v2.03, AltiVec, vupkhsb # Vector Unpack High Signed Byte
VUPKHSB PPC64LE 000100 vrt:5 00000 vrb:5 01000001110

@ format:VX, book:I, page:291, Vector, v2.03, AltiVec, vupkhsh # Vector Unpack High Signed Halfword
VUPKHSH PPC64LE 000100 vrt:5 00000 vrb:5 01001001110

@ format:VX, book:I, page:292, Vector, v2.07, vupkhsw # Vector Unpack High Signed Word
VUPKHSW PPC64LE 000100 vrt:5 00000 vrb:5 11001001110

@ format:VX, book:I, page:293, Vector, v2.03, AltiVec, vupklpx # Vector Unpack Low Pixel
VUPKLPX PPC64LE 000100 vrt:5 00000 vrb:5 01111001110

@ format:VX, book:I, page:290, Vector, v2.03, AltiVec, vupklsb # Vector Unpack Low Signed Byte
VUPKLSB PPC64LE 000100 vrt:5 00000 vrb:5 01010001110

@ format:VX, book:I, page:291, Vector, v2.03, AltiVec, vupklsh # Vector Unpack Low Signed Halfword
VUPKLSH PPC64LE 000100 vrt:5 00000 vrb:5 01011001110

@ format:VX, book:I, page:292, Vector, v2.07, vupklsw # Vector Unpack Low Signed Word
VUPKLSW PPC64LE 000100 vrt:5 00000 vrb:5 11011001110

@ format:VX, book:I, page:408, Vector, v2.03, AltiVec, vxor # Vector Logical XOR
VXOR PPC64LE 000100 vrt:5 vra:5 vrb:5 10011000100

@ format:X, book:II, page:1100, Storage_Control, v3.0, Skip, wait # Wait
WAIT PPC64LE 011111000 a:2 000000000000000111100

@ format:X, book:I, page:100, Fixed-Point, P1, SR, xor[.] # XOR
XOR PPC64LE 011111 rs:5 ra:5 rb:5 01001111000 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }
XORd PPC64LE 011111 rs:5 ra:5 rb:5 01001111001 \
!constraints { $rs != 1 && $ra != 1 && $rb != 1 && $rs != 13 && $ra != 13 && $rb != 13; }

@ format:D, book:I, page:100, Fixed-Point, P1, xori # XOR Immediate
XORI PPC64LE 011010 rs:5 ra:5 imm:16 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:D, book:I, page:100, Fixed-Point, P1, xoris # XOR Immediate Shifted
XORIS PPC64LE 011011 rs:5 ra:5 imm:16 \
!constraints { $rs != 1 && $ra != 1 && $rs != 13 && $ra != 13; }

@ format:XX2, book:I, page:666, Vector-Scalar_Extension, v2.06, xsabsdp # VSX Scalar Absolute Double-Precision
XSABSDP PPC64LE 111100 t:5 00000 b:5 10101 1001 bx:1 tx:1

@ format:X, book:I, page:666, Vector-Scalar_Extension, v3.0, BFP128, xsabsqp # VSX Scalar Absolute Quad-Precision
XSABSQP PPC64LE 111111 vrt:5 00000 vrb:5 11001 001000

@ format:XX3, book:I, page:667, Vector-Scalar_Extension, v2.06, xsadddp # VSX Scalar Add Double-Precision
XSADDDP PPC64LE 111100 t:5 a:5 b:5 00100 000 ax:1 bx:1 tx:1

@ format:X, book:I, page:674, Vector-Scalar_Extension, v3.0, BFP128, xsaddqp[o] # VSX Scalar Add Quad-Precision [using round to Odd]
XSADDQP PPC64LE 111111 vrt:5 vra:5 vrb:5 00000001000
XSADDQPo PPC64LE 111111 vrt:5 vra:5 vrb:5 00000001001

@ format:XX3, book:I, page:672, Vector-Scalar_Extension, v2.07, xsaddsp # VSX Scalar Add Single-Precision
XSADDSP PPC64LE 111100 t:5 a:5 b:5 00000000 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:678, Vector-Scalar_Extension, v3.0, xscmpeqdp # VSX Scalar Compare Equal Double-Precision
XSCMPEQDP PPC64LE 111100 t:5 a:5 b:5 00000011 ax:1 bx:1 tx:1

@ format:X, book:I, page:679, Vector-Scalar_Extension, v3.1, Skip, xscmpeqqp # VSX Scalar Compare Equal Quad-Precision
XSCMPEQQP PPC64LE 111111 a:15 00010001000

@ format:XX3, book:I, page:676, Vector-Scalar_Extension, v3.0, xscmpexpdp # VSX Scalar Compare Exponents Double-Precision
XSCMPEXPDP PPC64LE 111100 bf:3 00 a:5 b:5 00111011 ax:1 bx:1 0

@ format:X, book:I, page:677, Vector-Scalar_Extension, v3.0, BFP128, xscmpexpqp # VSX Scalar Compare Exponents Quad-Precision
XSCMPEXPQP PPC64LE 111111 bf:3 00 vra:5 vrb:5 00101001000

@ format:XX3, book:I, page:680, Vector-Scalar_Extension, v3.0, xscmpgedp # VSX Scalar Compare Greater Than or Equal Double-Precision
XSCMPGEDP PPC64LE 111100 t:5 a:5 b:5 00010011 ax:1 bx:1 tx:1

@ format:X, book:I, page:681, Vector-Scalar_Extension, v3.1, Skip, xscmpgeqp # VSX Scalar Compare Greater Than or Equal Quad-Precision
XSCMPGEQP PPC64LE 111111 a:15 00110001000

@ format:XX3, book:I, page:682, Vector-Scalar_Extension, v3.0, xscmpgtdp # VSX Scalar Compare Greater Than Double-Precision
XSCMPGTDP PPC64LE 111100 t:5 a:5 b:5 00001011 ax:1 bx:1 tx:1

@ format:X, book:I, page:683, Vector-Scalar_Extension, v3.1, Skip, xscmpgtqp # VSX Scalar Compare Greater Than Quad-Precision
XSCMPGTQP PPC64LE 111111 a:15 00111001000

@ format:XX3, book:I, page:684, Vector-Scalar_Extension, v2.06, xscmpodp # VSX Scalar Compare Ordered Double-Precision
XSCMPODP PPC64LE 111100 bf:3 00 a:5 b:5 00101011 ax:1 bx:1 0

@ format:X, book:I, page:686, Vector-Scalar_Extension, v3.0, BFP128, xscmpoqp # VSX Scalar Compare Ordered Quad-Precision
XSCMPOQP PPC64LE 111111 bf:3 00 vra:5 vrb:5 00100001000

@ format:XX3, book:I, page:687, Vector-Scalar_Extension, v2.06, xscmpudp # VSX Scalar Compare Unordered Double-Precision
XSCMPUDP PPC64LE 111100 bf:3 00 a:5 b:5 00100011 ax:1 bx:1 0

@ format:X, book:I, page:689, Vector-Scalar_Extension, v3.0, BFP128, xscmpuqp # VSX Scalar Compare Unordered Quad-Precision
XSDMPUQP PPC64LE 111111 bf:3 00 vra:5 vrb:5 10100001000

@ format:XX3, book:I, page:690, Vector-Scalar_Extension, v2.06, xscpsgndp # VSX Scalar Copy Sign Double-Precision
XSCPSGNDP PPC64LE 111100 t:5 a:5 b:5 10110000 ax:1 bx:1 tx:1

@ format:X, book:I, page:690, Vector-Scalar_Extension, v3.0, BFP128, xscpsgnqp # VSX Scalar Copy Sign Quad-Precision
XSCPSGNQP PPC64LE 111111 vrt:5 vra:5 vrb:5 00011001000

@ format:XX2, book:I, page:691, Vector-Scalar_Extension, v3.0, xscvdphp # VSX Scalar Convert with round Double-Precision to Half-Precision format
XSCVDPHP PPC64LE 111100 t:5 10001 b:5 101011011 bx:1 tx:1

@ format:X, book:I, page:692, Vector-Scalar_Extension, v3.0, BFP128, xscvdpqp # VSX Scalar Convert Double-Precision to Quad-Precision format
XSCVDPQP PPC64LE 111111 vrt:5 10110 vrb:5 11010001000

@ format:XX2, book:I, page:693, Vector-Scalar_Extension, v2.06, xscvdpsp # VSX Scalar Convert with round Double-Precision to Single-Precision format
XSCVDPSP PPC64LE 111100 t:5 00000 b:5 100001001 bx:1 tx:1

@ format:XX2, book:I, page:694, Vector-Scalar_Extension, v2.07, xscvdpspn # VSX Scalar Convert Scalar Single-Precision to Vector Single-Precision format Non-signalling
XSCVDPSPN PPC64LE 111100 t:5 00000 b:5 100001011 bx:1 tx:1

@ format:XX2, book:I, page:695, Vector-Scalar_Extension, v2.06, xscvdpsxds # VSX Scalar Convert with round to zero Double-Precision to Signed Doubleword format
XSCVDPSXDS PPC64LE 111100 t:5 00000 b:5 101011000 bx:1 tx:1

@ format:XX2, book:I, page:697, Vector-Scalar_Extension, v2.06, xscvdpsxws # VSX Scalar Convert with round to zero Double-Precision to Signed Word format
XSCVDPSXWS PPC64LE 111100 t:5 00000 b:5 001011000 bx:1 tx:1

@ format:XX2, book:I, page:699, Vector-Scalar_Extension, v2.06, xscvdpuxds # VSX Scalar Convert with round to zero Double-Precision to Unsigned Doubleword format
XSCVDPUXDS PPC64LE 111100 t:5 00000 b:5 101001000 bx:1 tx:1

@ format:XX2, book:I, page:701, Vector-Scalar_Extension, v2.06, xscvdpuxws # VSX Scalar Convert with round to zero Double-Precision to Unsigned Word format
XSCVDPUXWS PPC64LE 111100 t:5 00000 b:5 001001000 bx:1 tx:1

@ format:XX2, book:I, page:703, Vector-Scalar_Extension, v3.0, xscvhpdp # VSX Scalar Convert Half-Precision to Double-Precision format
XSVCHPDP PPC64LE 111100 t:5 10000 b:5 101011011 bx:1 tx:1

@ format:X, book:I, page:704, Vector-Scalar_Extension, v3.0, BFP128, xscvqpdp[o] # VSX Scalar Convert with round Quad-Precision to Double-Precision format [using round to Odd]
XSCVQPDP PPC64LE 111111 vrt:5 10100 vrb:5 11010001000
XSCVQPDPo PPC64LE 111111 vrt:5 10100 vrb:5 11010001001

@ format:X, book:I, page:705, Vector-Scalar_Extension, v3.0, BFP128, xscvqpsdz # VSX Scalar Convert with round to zero Quad-Precision to Signed Doubleword format
XSCVQPSDZ PPC64LE 111111 vrt:5 11001 vrb:5 11010 001000

@ format:X, book:I, page:707, Vector-Scalar_Extension, v3.1, Skip, xscvqpsqz # VSX Scalar Convert with round to zero Quad-Precision to Signed Quadword
XSCVQPSQZ PPC64LE 111111 a:5 01000 b:5 11010001000

@ format:X, book:I, page:709, Vector-Scalar_Extension, v3.0, BFP128, xscvqpswz # VSX Scalar Convert with round to zero Quad-Precision to Signed Word format
XSCVQPSWZ PPC64LE 111111 vrt:5 01001 vrb:5 11010 001000

@ format:X, book:I, page:711, Vector-Scalar_Extension, v3.0, BFP128, xscvqpudz # VSX Scalar Convert with round to zero Quad-Precision to Unsigned Doubleword format
XSCVQPUDZ PPC64LE 111111 vrt:5 10001 vrb:5 11010 001000

@ format:X, book:I, page:713, Vector-Scalar_Extension, v3.1, Skip, xscvqpuqz # VSX Scalar Convert with round to zero Quad-Precision to Unsigned Quadword
XSCVQPUQZ PPC64LE 111111 a:5 00000 b:5 11010001000

@ format:X, book:I, page:715, Vector-Scalar_Extension, v3.0, BFP128, xscvqpuwz # VSX Scalar Convert with round to zero Quad-Precision to Unsigned Word format
XSCVQPUWZ PPC64LE 111111 vrt:5 00001 vrb:5 11010 001000

@ format:X, book:I, page:722, Vector-Scalar_Extension, v3.0, BFP128, xscvsdqp # VSX Scalar Convert Signed Doubleword to Quad-Precision format
XSCVSDQP PPC64LE 111111 vrt:5 01010 vrb:5 11010 001000

@ format:XX2, book:I, page:717, Vector-Scalar_Extension, v2.06, xscvspdp # VSX Scalar Convert Single-Precision to Double-Precision format
XSCVSPDP PPC64LE 111100 t:5 00000 b:5 10100 1001 bx:1 tx:1

@ format:XX2, book:I, page:718, Vector-Scalar_Extension, v2.07, xscvspdpn # VSX Scalar Convert Single-Precision to Double-Precision format Non-signalling
XSCVSPDPN PPC64LE 111100 t:5 00000 b:5 10100 1011 bx:1 tx:1

@ format:X, book:I, page:719, Vector-Scalar_Extension, v3.1, Skip, xscvsqqp # VSX Scalar Convert with round Signed Quadword to Quad-Precision
XSCVSQQP PPC64LE 111111 a:5 01011 b:5 11010001000

@ format:XX2, book:I, page:720, Vector-Scalar_Extension, v2.06, xscvsxddp # VSX Scalar Convert with round Signed Doubleword to Double-Precision format
XSCVSXDDP PPC64LE 111100 t:5 00000 b:5 10111 1000 bx:1 tx:1

@ format:XX2, book:I, page:721, Vector-Scalar_Extension, v2.07, xscvsxdsp # VSX Scalar Convert with round Signed Doubleword to Single-Precision format
XSCVSXDSP PPC64LE 111100 t:5 00000 b:5 10011 1000 bx:1 tx:1

@ format:X, book:I, page:722, Vector-Scalar_Extension, v3.0, BFP128, xscvudqp # VSX Scalar Convert Unsigned Doubleword to Quad-Precision format
XSCVUDQP PPC64LE 111111 vrt:5 00010 vrb:5 11010 001000

@ format:X, book:I, page:723, Vector-Scalar_Extension, v3.1, Skip, xscvuqqp # VSX Scalar Convert with round Unsigned Quadword to Quad-Precision
XSCVUQQP PPC64LE 111111 a:5 00011 b:5 11010001000

@ format:XX2, book:I, page:723, Vector-Scalar_Extension, v2.06, xscvuxddp # VSX Scalar Convert with round Unsigned Doubleword to Double-Precision format
XSCVUXDDP PPC64LE 111100 t:5 00000 b:5 10110 1000 bx:1 tx:1

@ format:XX2, book:I, page:724, Vector-Scalar_Extension, v2.07, xscvuxdsp # VSX Scalar Convert with round Unsigned Doubleword to Single-Precision
XSCVUXDSP PPC64LE 111100 t:5 00000 b:5 10010 1000 bx:1 tx:1

@ format:XX3, book:I, page:725, Vector-Scalar_Extension, v2.06, xsdivdp # VSX Scalar Divide Double-Precision
XSDIVDP PPC64LE 111100 t:5 a:5 b:5 00111000 ax:1 bx:1 tx:1

@ format:X, book:I, page:727, Vector-Scalar_Extension, v3.0, BFP128, xsdivqp[o] # VSX Scalar Divide Quad-Precision [using round to Odd]
XSDIVQP PPC64LE 111111 vrt:5 vra:5 vrb:5 10001001000
XSDIVQPo PPC64LE 111111 vrt:5 vra:5 vrb:5 10001001001

@ format:XX3, book:I, page:729, Vector-Scalar_Extension, v2.07, xsdivsp # VSX Scalar Divide Single-Precision
XSDIVSP PPC64LE 111100 t:5 a:5 b:5 00011 000 ax:1 bx:1 tx:1

@ format:X, book:I, page:731, Vector-Scalar_Extension, v3.0, xsiexpdp # VSX Scalar Insert Exponent Double-Precision
XSIEXPDP PPC64LE 111100 t:5 ra:5 rb:5 1110010110 tx:1 \
!constraints { $ra != 1 && $rb != 1 && $ra != 13 && $rb != 13; }

@ format:X, book:I, page:732, Vector-Scalar_Extension, v3.0, BFP128, xsiexpqp # VSX Scalar Insert Exponent Quad-Precision
XSIEXPQP PPC64LE 111111 vrt:5 vra:5 vrb:5 11011001000

@ format:XX3, book:I, page:733, Vector-Scalar_Extension, v2.06, xsmaddadp # VSX Scalar Multiply-Add Type-A Double-Precision
XSMADDADP PPC64LE 111100 t:5 a:5 b:5 00100 001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:736, Vector-Scalar_Extension, v2.07, xsmaddasp # VSX Scalar Multiply-Add Type-A Single-Precision
XSMADDASP PPC64LE 111100 t:5 a:5 b:5 00000 001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:733, Vector-Scalar_Extension, v2.06, xsmaddmdp # VSX Scalar Multiply-Add Type-M Double-Precision
XSMADDMDP PPC64LE 111100 t:5 a:5 b:5 00101 001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:736, Vector-Scalar_Extension, v2.07, xsmaddmsp # VSX Scalar Multiply-Add Type-M Single-Precision
XSMADDMSP PPC64LE 111100 t:5 a:5 b:5 00001 001 ax:1 bx:1 tx:1

@ format:X, book:I, page:739, Vector-Scalar_Extension, v3.0, BFP128, xsmaddqp[o] # VSX Scalar Multiply-Add Quad-Precision [using round to Odd]
XSMADDQP PPC64LE 111111 vrt:5 vra:5 vrb:5 01100 001000
XSMADDQPo PPC64LE 111111 vrt:5 vra:5 vrb:5 01100 001001

@ format:XX3, book:I, page:744, Vector-Scalar_Extension, v3.0, xsmaxcdp # VSX Scalar Maximum Type-C Double-Precision
XSMAXCDP PPC64LE 111100 t:5 a:5 b:5 10000000 ax:1 bx:1 tx:1

@ format:X, book:I, page:746, Vector-Scalar_Extension, v3.1, Skip, xsmaxcqp # VSX Scalar Maximum Type-C Quad-Precision
XSMAXCQP PPC64LE 111111 a:15 10101001000

@ format:XX3, book:I, page:742, Vector-Scalar_Extension, v2.06, xsmaxdp # VSX Scalar Maximum Double-Precision
XSMAXDP PPC64LE 111100 t:5 a:5 b:5 10100000 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:748, Vector-Scalar_Extension, v3.0, xsmaxjdp # VSX Scalar Maximum Type-J Double-Precision
XMAXJDP PPC64LE 111100 t:5 a:5 b:5 10010000 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:752, Vector-Scalar_Extension, v3.0, xsmincdp # VSX Scalar Minimum Type-C Double-Precision
XSMINCDP PPC64LE 111100 t:5 a:5 b:5 10001000 ax:1 bx:1 tx:1

@ format:X, book:I, page:754, Vector-Scalar_Extension, v3.1, Skip, xsmincqp # VSX Scalar Minimum Type-C Quad-Precision
XSMINCQP PPC64LE 111111 a:15 10111001000

@ format:XX3, book:I, page:750, Vector-Scalar_Extension, v2.06, xsmindp # VSX Scalar Minimum Double-Precision
XSMINDP PPC64LE 111100 t:5 a:5 b:5 10101000 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:755, Vector-Scalar_Extension, v3.0, xsminjdp # VSX Scalar Minimum Type-J Double-Precision
XSMINJDP PPC64LE 111100 t:5 a:5 b:5 10011000 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:757, Vector-Scalar_Extension, v2.06, xsmsubadp # VSX Scalar Multiply-Subtract Type-A Double-Precision
XSMSUBADP PPC64LE 111100 t:5 a:5 b:5 00110001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:760, Vector-Scalar_Extension, v2.07, xsmsubasp # VSX Scalar Multiply-Subtract Type-A Single-Precision
XSMSUBASP PPC64LE 111100 t:5 a:5 b:5 00010001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:757, Vector-Scalar_Extension, v2.06, xsmsubmdp # VSX Scalar Multiply-Subtract Type-M Double-Precision
XSMSUBMDP PPC64LE 111100 t:5 a:5 b:5 00111001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:760, Vector-Scalar_Extension, v2.07, xsmsubmsp # VSX Scalar Multiply-Subtract Type-M Single-Precision
XSMSUBMSP PPC64LE 111100 t:5 a:5 b:5 00011001 ax:1 bx:1 tx:1

@ format:X, book:I, page:763, Vector-Scalar_Extension, v3.0, BFP128, xsmsubqp[o] # VSX Scalar Multiply-Subtract Quad-Precision [using round to Odd]
XSMSUBQP PPC64LE 111111 vrt:5 vra:5 vrb:5 01101001000
XSMSUBQPo PPC64LE 111111 vrt:5 vra:5 vrb:5 01101001001

@ format:XX3, book:I, page:766, Vector-Scalar_Extension, v2.06, xsmuldp # VSX Scalar Multiply Double-Precision
XSMULDP PPC64LE 111100 t:5 a:5 b:5 00110000 ax:1 bx:1 tx:1

@ format:X, book:I, page:768, Vector-Scalar_Extension, v3.0, BFP128, xsmulqp[o] # VSX Scalar Multiply Quad-Precision [using round to Odd]
XSMULQP PPC64LE 111111 vrt:5 vra:5 vrb:5 00001001000
XSMULQPo PPC64LE 111111 vrt:5 vra:5 vrb:5 00001001001

@ format:XX3, book:I, page:770, Vector-Scalar_Extension, v2.07, xsmulsp # VSX Scalar Multiply Single-Precision
XSMULSP PPC64LE 111100 t:5 a:5 b:5 00010000 ax:1 bx:1 tx:1

@ format:XX2, book:I, page:772, Vector-Scalar_Extension, v2.06, xsnabsdp # VSX Scalar Negative Absolute Double-Precision
XSNABSDP PPC64LE 111100 t:5 00000 b:5 10110 1001 bx:1 tx:1

@ format:X, book:I, page:772, Vector-Scalar_Extension, v3.0, BFP128, xsnabsqp # VSX Scalar Negative Absolute Quad-Precision
XSNABSQP PPC64LE 111111 vrt:5 01000 vrb:5 11001 001000

@ format:XX2, book:I, page:773, Vector-Scalar_Extension, v2.06, xsnegdp # VSX Scalar Negate Double-Precision
XSNEGDP PPC64LE 111100 t:5 00000 b:5 10111 1001 bx:1 tx:1

@ format:X, book:I, page:773, Vector-Scalar_Extension, v3.0, BFP128, xsnegqp # VSX Scalar Negate Quad-Precision
XSNEGQP PPC64LE 111111 vrt:5 10000 vrb:5 11001 001000

@ format:XX3, book:I, page:774, Vector-Scalar_Extension, v2.06, xsnmaddadp # VSX Scalar Negative Multiply-Add Type-A Double-Precision
XSNMADDADP PPC64LE 111100 t:5 a:5 b:5 10100001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:779, Vector-Scalar_Extension, v2.07, xsnmaddasp # VSX Scalar Negative Multiply-Add Type-A Single-Precision
XSNMADDASP PPC64LE 111100 t:5 a:5 b:5 10000001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:774, Vector-Scalar_Extension, v2.06, xsnmaddmdp # VSX Scalar Negative Multiply-Add Type-M Double-Precision
XSNMADDMDP PPC64LE 111100 t:5 a:5 b:5 10101001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:779, Vector-Scalar_Extension, v2.07, xsnmaddmsp # VSX Scalar Negative Multiply-Add Type-M Single-Precision
XSNMADDMSP PPC64LE 111100 t:5 a:5 b:5 10001001 ax:1 bx:1 tx:1

@ format:X, book:I, page:782, Vector-Scalar_Extension, v3.0, BFP128, xsnmaddqp[o] # VSX Scalar Negative Multiply-Add Quad-Precision [using round to Odd]
XSNMADDQP PPC64LE 111111 vrt:5 vra:5 vrb:5 01110001000
XSNMADDQPo PPC64LE 111111 vrt:5 vra:5 vrb:5 01110001001

@ format:XX3, book:I, page:785, Vector-Scalar_Extension, v2.06, xsnmsubadp # VSX Scalar Negative Multiply-Subtract Type-A Double-Precision
XSNMSUBSDP PPC64LE 111100 t:5 a:5 b:5 10110001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:788, Vector-Scalar_Extension, v2.07, xsnmsubasp # VSX Scalar Negative Multiply-Subtract Type-A Single-Precision
XSNMSUBSAP PPC64LE 111100 t:5 a:5 b:5 10010001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:785, Vector-Scalar_Extension, v2.06, xsnmsubmdp # VSX Scalar Negative Multiply-Subtract Type-M Double-Precision
XSNMSUBMDP PPC64LE 111100 t:5 a:5 b:5 10111001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:788, Vector-Scalar_Extension, v2.07, xsnmsubmsp # VSX Scalar Negative Multiply-Subtract Type-M Single-Precision
XSNMSUBMSP PPC64LE 111100 t:5 a:5 b:5 10011001 ax:1 bx:1 tx:1

@ format:X, book:I, page:791, Vector-Scalar_Extension, v3.0, BFP128, xsnmsubqp[o] # VSX Scalar Negative Multiply-Subtract Quad-Precision [using round to Odd]
XSNMSUBQP PPC64LE 111111 vrt:5 vra:5 vrb:5 01111001000
XSNMSUBQPo PPC64LE 111111 vrt:5 vra:5 vrb:5 01111001001

@ format:XX2, book:I, page:794, Vector-Scalar_Extension, v2.06, xsrdpi # VSX Scalar Round to Double-Precision Integer using round to Nearest Away
XSRDPI PPC64LE 111100 t:5 00000 b:5 00100 1001 bx:1 tx:1

@ format:XX2, book:I, page:795, Vector-Scalar_Extension, v2.06, xsrdpic # VSX Scalar Round to Double-Precision Integer exact using Current rounding mode
XSRDPIC PPC64LE 111100 t:5 00000 b:5 00110 1011 bx:1 tx:1

@ format:XX2, book:I, page:796, Vector-Scalar_Extension, v2.06, xsrdpim # VSX Scalar Round to Double-Precision Integer using round toward -Infinity
XSRDPIM PPC64LE 111100 t:5 00000 b:5 00111 1001 bx:1 tx:1

@ format:XX2, book:I, page:797, Vector-Scalar_Extension, v2.06, xsrdpip # VSX Scalar Round to Double-Precision Integer using round toward +Infinity
XSRDPIP PPC64LE 111100 t:5 00000 b:5 00110 1001 bx:1 tx:1

@ format:XX2, book:I, page:798, Vector-Scalar_Extension, v2.06, xsrdpiz # VSX Scalar Round to Double-Precision Integer using round toward Zero
XSRDPIZ PPC64LE 111100 t:5 00000 b:5 00101 1001 bx:1 tx:1

@ format:XX2, book:I, page:799, Vector-Scalar_Extension, v2.06, xsredp # VSX Scalar Reciprocal Estimate Double-Precision
XSREDP PPC64LE 111100 t:5 00000 b:5 00101 1010 bx:1 tx:1

@ format:XX2, book:I, page:800, Vector-Scalar_Extension, v2.07, xsresp # VSX Scalar Reciprocal Estimate Single-Precision
XSRESP PPC64LE 111100 t:5 00000 b:5 00001 1010 bx:1 tx:1

@ format:Z23, book:I, page:802, Vector-Scalar_Extension, v3.0, BFP128, xsrqpi[x] # VSX Scalar Round to Quad-Precision Integer [with Inexact]
XSRQPI PPC64LE 111111 vrt:5 0000 r:1 vrb:5 rmc:2 000001010 \
!constraints { ($r == 0 && ($rmc != 1 && $rmc != 2)) || $r == 1; }
XSRQPIx PPC64LE 111111 vrt:5 0000 r:1 vrb:5 rmc:2 000001011 \
!constraints { ($r == 0 && ($rmc != 1 && $rmc != 2)) || $r == 1; }

@ format:Z23, book:I, page:804, Vector-Scalar_Extension, v3.0, BFP128, xsrqpxp # VSX Scalar Round Quad-Precision to Double-Extended Precision
XSRQPXP PPC64LE 111111 vrt:5 0000 r:1 vrb:5 rmc:2 001001010 \
!constraints { ($r == 0 && ($rmc != 1 && $rmc != 2)) || $r == 1; }

@ format:XX2, book:I, page:806, Vector-Scalar_Extension, v2.07, xsrsp # VSX Scalar Round to Single-Precision
XSRSP PPC64LE 111100 t:5 00000 b:5 10001 1001 bx:1 tx:1

@ format:XX2, book:I, page:807, Vector-Scalar_Extension, v2.06, xsrsqrtedp # VSX Scalar Reciprocal Square Root Estimate Double-Precision
XSRSQRTEDP PPC64LE 111100 t:5 00000 b:5 00100 1010 bx:1 tx:1

@ format:XX2, book:I, page:808, Vector-Scalar_Extension, v2.07, xsrsqrtesp # VSX Scalar Reciprocal Square Root Estimate Single-Precision
XSRSQRTESP PPC64LE 111100 t:5 00000 b:5 00000 1010 bx:1 tx:1

@ format:XX2, book:I, page:810, Vector-Scalar_Extension, v2.06, xssqrtdp # VSX Scalar Square Root Double-Precision
XSSQRTDP PPC64LE 111100 t:5 00000 b:5 00100 1011 bx:1 tx:1

@ format:X, book:I, page:812, Vector-Scalar_Extension, v3.0, BFP128, xssqrtqp[o] # VSX Scalar Square Root Quad-Precision [using round to Odd]
XSSQRTQP PPC64LE 111111 vrt:5 11011 vrb:5 11001001000
XSSQRTQPo PPC64LE 111111 vrt:5 11011 vrb:5 11001001001

@ format:XX2, book:I, page:814, Vector-Scalar_Extension, v2.07, xssqrtsp # VSX Scalar Square Root Single-Precision
XSSQRTSP PPC64LE 111100 t:5 00000 b:5 00000 1011 bx:1 tx:1

@ format:XX3, book:I, page:816, Vector-Scalar_Extension, v2.06, xssubdp # VSX Scalar Subtract Double-Precision
XSSUBDP PPC64LE 111100 t:5 a:5 b:5 00101 000 ax:1 bx:1 tx:1

@ format:X, book:I, page:818, Vector-Scalar_Extension, v3.0, BFP128, xssubqp[o] # VSX Scalar Subtract Quad-Precision [using round to Odd]
XSSUBQP PPC64LE 111111 vrt:5 vra:5 vrb:5 10000 001000
XSSUBQPo PPC64LE 111111 vrt:5 vra:5 vrb:5 10000 001001

@ format:XX3, book:I, page:820, Vector-Scalar_Extension, v2.07, xssubsp # VSX Scalar Subtract Single-Precision
XSSUBSP PPC64LE 111100 t:5 a:5 b:5 00001 000 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:822, Vector-Scalar_Extension, v2.06, xstdivdp # VSX Scalar Test for software Divide Double-Precision
XSTDIVDP PPC64LE 111100 bf:3 00 a:5 b:5 00111101 ax:1 bx:1 0

@ format:XX2, book:I, page:823, Vector-Scalar_Extension, v2.06, xstsqrtdp # VSX Scalar Test for software Square Root Double-Precision
XSTSQRTDP PPC64LE 111100 bf:3 0000000 b:5 001101010 bx:1 0

@ format:XX2, book:I, page:824, Vector-Scalar_Extension, v3.0, xststdcdp # VSX Scalar Test Data Class Double-Precision
XSTSTDCDP PPC64LE 111100 bf:3 dcmx:7 b:5 101101010 bx:1 0

@ format:X, book:I, page:825, Vector-Scalar_Extension, v3.0, BFP128, xststdcqp # VSX Scalar Test Data Class Quad-Precision
XSTSTDCQP PPC64LE 111111 vrt:5 vra:5 vrb:5 10110 001000

@ format:XX2, book:I, page:826, Vector-Scalar_Extension, v3.0, xststdcsp # VSX Scalar Test Data Class Single-Precision
XSTSTDCSP PPC64LE 111100 bf:3 dcmx:7 b:5 100101010 bx:1 0

@ format:XX2, book:I, page:827, Vector-Scalar_Extension, v3.0, xsxexpdp # VSX Scalar Extract Exponent Double-Precision
XSXEXPDP PPC64LE 111100 rt:5 00000 b:5 101011011 bx:1 0 \
!constraints { $rt != 1 && $rt != 13; }

@ format:X, book:I, page:827, Vector-Scalar_Extension, v3.0, BFP128, xsxexpqp # VSX Scalar Extract Exponent Quad-Precision
XSXEXPQP PPC64LE 111111 vrt:5 00010 vrb:5 11001001000

@ format:XX2, book:I, page:828, Vector-Scalar_Extension, v3.0, xsxsigdp # VSX Scalar Extract Significand Double-Precision
XSXSIGDP PPC64LE 111100 rt:5 00001 b:5 101011011 bx:1 0 \
!constraints { $rt != 1 && $rt != 13; }

@ format:X, book:I, page:828, Vector-Scalar_Extension, v3.0, BFP128, xsxsigqp # VSX Scalar Extract Significand Quad-Precision
XSXSIGQP PPC64LE 111111 vrt:5 10010 vrb:5 11001 001000

@ format:XX2, book:I, page:829, Vector-Scalar_Extension, v2.06, xvabsdp # VSX Vector Absolute Value Double-Precision
XVABSDP PPC64LE 111100 t:5 00000 b:5 11101 1001 bx:1 tx:1

@ format:XX2, book:I, page:829, Vector-Scalar_Extension, v2.06, xvabssp # VSX Vector Absolute Value Single-Precision
XVABSSP PPC64LE 111100 t:5 00000 b:5 11001 1001 bx:1 tx:1

@ format:XX3, book:I, page:830, Vector-Scalar_Extension, v2.06, xvadddp # VSX Vector Add Double-Precision
XVADDDP PPC64LE 111100 t:5 a:5 b:5 01100000 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:834, Vector-Scalar_Extension, v2.06, xvaddsp # VSX Vector Add Single-Precision
XVADDSP PPC64LE 111100 t:5 a:5 b:5 01000000 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:836, Vector-Scalar_Extension, v3.1, MMA, Skip, xvbf16ger2 # VSX Vector bfloat16 GER (Rank-2 Update)
XVBF16GER2 PPC64LE 111011 a:3 00 b:10 00110011 c:2 0

@ format:XX3, book:I, page:836, Vector-Scalar_Extension, v3.1, MMA, Skip, xvbf16ger2nn # VSX Vector bfloat16 GER (Rank-2 Update) Negative multiply, Negative accumulate
XVBF16GER2NN PPC64LE 111011 a:3 00 b:10 11110010 c:2 0

@ format:XX3, book:I, page:836, Vector-Scalar_Extension, v3.1, MMA, Skip, xvbf16ger2np # VSX Vector bfloat16 GER (Rank-2 Update) Negative multiply, Positive accumulate
XVBF16GER2NP PPC64LE 111011 a:3 00 b:10 01110010 c:2 0

@ format:XX3, book:I, page:836, Vector-Scalar_Extension, v3.1, MMA, Skip, xvbf16ger2pn # VSX Vector bfloat16 GER (Rank-2 Update) Positive multiply, Negative accumulate
XVBF16GER2PN PPC64LE 111011 a:3 00 b:10 10110010 c:2 0

@ format:XX3, book:I, page:836, Vector-Scalar_Extension, v3.1, MMA, Skip, xvbf16ger2pp # VSX Vector bfloat16 GER (Rank-2 Update) Positive multiply, Positive accumulate
XVBF16GER2PP PPC64LE 111011 a:3 00 b:10 00110010 c:2 0

@ format:XX3, book:I, page:841, Vector-Scalar_Extension, v2.06, xvcmpeqdp[.] # VSX Vector Compare Equal To Double-Precision
XVCMPEQDP PPC64LE 111100 t:5 a:5 b:5 01100011 ax:1 bx:1 tx:1
XVCMPEQDPd PPC64LE 111100 t:5 a:5 b:5 11100011 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:842, Vector-Scalar_Extension, v2.06, xvcmpeqsp[.] # VSX Vector Compare Equal To Single-Precision
XVCMPEQSP PPC64LE 111100 t:5 a:5 b:5 01000011 ax:1 bx:1 tx:1
XVCMPEQSPd PPC64LE 111100 t:5 a:5 b:5 11000011 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:843, Vector-Scalar_Extension, v2.06, xvcmpgedp[.] # VSX Vector Compare Greater Than or Equal To Double-Precision
XVCMPGEDP PPC64LE 111100 t:5 a:5 b:5 01110011 ax:1 bx:1 tx:1
XVCMPGEDPd PPC64LE 111100 t:5 a:5 b:5 11110011 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:844, Vector-Scalar_Extension, v2.06, xvcmpgesp[.] # VSX Vector Compare Greater Than or Equal To Single-Precision
XVDMPGESP PPC64LE 111100 t:5 a:5 b:5 01010011 ax:1 bx:1 tx:1
XVCMPGESPd PPC64LE 111100 t:5 a:5 b:5 11010011 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:845, Vector-Scalar_Extension, v2.06, xvcmpgtdp[.] # VSX Vector Compare Greater Than Double-Precision
XVCMPGTDP PPC64LE 111100 t:5 a:5 b:5 01101011 ax:1 bx:1 tx:1
XVCMPGTDPd PPC64LE 111100 t:5 a:5 b:5 11101011 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:846, Vector-Scalar_Extension, v2.06, xvcmpgtsp[.] # VSX Vector Compare Greater Than Single-Precision
XVCMPGTSP PPC64LE 111100 t:5 a:5 b:5 01001011 ax:1 bx:1 tx:1
XVCMPGTSPd PPC64LE 111100 t:5 a:5 b:5 11001011 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:847, Vector-Scalar_Extension, v2.06, xvcpsgndp # VSX Vector Copy Sign Double-Precision
XVCPSGNDP PPC64LE 111100 t:5 a:5 b:5 11110000 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:847, Vector-Scalar_Extension, v2.06, xvcpsgnsp # VSX Vector Copy Sign Single-Precision
XVCPSGNSP PPC64LE 111100 t:5 a:5 b:5 11010000 ax:1 bx:1 tx:1

@ format:XX2, book:I, page:848, Vector-Scalar_Extension, v3.1, Skip, xvcvbf16sp # VSX Vector Convert bfloat16 to Single-Precision format Non-signaling
XVCVBF16SP PPC64LE 111100 a:5 10000 b:5 111011011 c:2

@ format:XX2, book:I, page:849, Vector-Scalar_Extension, v2.06, xvcvdpsp # VSX Vector Convert with round Double-Precision to Single-Precision format
XVCVDPSP PPC64LE 111100 t:5 00000 b:5 11000 1001 bx:1 tx:1

@ format:XX2, book:I, page:850, Vector-Scalar_Extension, v2.06, xvcvdpsxds # VSX Vector Convert with round to zero Double-Precision to Signed Doubleword format
XVCVPSXDS PPC64LE 111100 t:5 00000 b:5 11101 1000 bx:1 tx:1

@ format:XX2, book:I, page:852, Vector-Scalar_Extension, v2.06, xvcvdpsxws # VSX Vector Convert with round to zero Double-Precision to Signed Word format
XVCVDPSXWS PPC64LE 111100 t:5 00000 b:5 01101 1000 bx:1 tx:1

@ format:XX2, book:I, page:854, Vector-Scalar_Extension, v2.06, xvcvdpuxds # VSX Vector Convert with round to zero Double-Precision to Unsigned Doubleword format
XVCVDPUXDS PPC64LE 111100 t:5 00000 b:5 11100 1000 bx:1 tx:1

@ format:XX2, book:I, page:856, Vector-Scalar_Extension, v2.06, xvcvdpuxws # VSX Vector Convert with round to zero Double-Precision to Unsigned Word format
XVCVDPUXWS PPC64LE 111100 t:5 00000 b:5 01100 1000 bx:1 tx:1

@ format:XX2, book:I, page:858, Vector-Scalar_Extension, v3.0, xvcvhpsp # VSX Vector Convert Half-Precision to Single-Precision format
XVCVHPSP PPC64LE 111100 t:5 11000 b:5 11101 1011 bx:1 tx:1

@ format:XX2, book:I, page:859, Vector-Scalar_Extension, v3.1, Skip, xvcvspbf16 # VSX Vector Convert with round Single-Precision to bfloat16 format
XVCVSPBF16 PPC64LE 111100 a:5 10001 b:5 111011011 c:2

@ format:XX2, book:I, page:860, Vector-Scalar_Extension, v2.06, xvcvspdp # VSX Vector Convert Single-Precision to Double-Precision format
XVCVSPDP PPC64LE 111100 t:5 00000 b:5 11100 1001 bx:1 tx:1

@ format:XX2, book:I, page:861, Vector-Scalar_Extension, v3.0, xvcvsphp # VSX Vector Convert with round Single-Precision to Half-Precision format
XVCVSPHP PPC64LE 111100 t:5 11001 b:5 11101 1011 bx:1 tx:1

@ format:XX2, book:I, page:862, Vector-Scalar_Extension, v2.06, xvcvspsxds # VSX Vector Convert with round to zero Single-Precision to Signed Doubleword format
XVCVSPSXDS PPC64LE 111100 t:5 00000 b:5 11001 1000 bx:1 tx:1

@ format:XX2, book:I, page:864, Vector-Scalar_Extension, v2.06, xvcvspsxws # VSX Vector Convert with round to zero Single-Precision to Signed Word format
XVCVSPSXWS PPC64LE 111100 t:5 00000 b:5 01001 1000 bx:1 tx:1

@ format:XX2, book:I, page:866, Vector-Scalar_Extension, v2.06, xvcvspuxds # VSX Vector Convert with round to zero Single-Precision to Unsigned Doubleword format
XVCVSPUXDS PPC64LE 111100 t:5 00000 b:5 11000 1000 bx:1 tx:1

@ format:XX2, book:I, page:868, Vector-Scalar_Extension, v2.06, xvcvspuxws # VSX Vector Convert with round to zero Single-Precision to Unsigned Word format
XVCVSPUXWS PPC64LE 111100 t:5 00000 b:5 01000 1000 bx:1 tx:1

@ format:XX2, book:I, page:870, Vector-Scalar_Extension, v2.06, xvcvsxddp # VSX Vector Convert with round Signed Doubleword to Double-Precision format
XVCVSXDDP PPC64LE 111100 t:5 00000 b:5 11111 1000 bx:1 tx:1

@ format:XX2, book:I, page:871, Vector-Scalar_Extension, v2.06, xvcvsxdsp # VSX Vector Convert with round Signed Doubleword to Single-Precision format
XVCVSXDSP PPC64LE 111100 t:5 00000 b:5 11011 1000 bx:1 tx:1

@ format:XX2, book:I, page:872, Vector-Scalar_Extension, v2.06, xvcvsxwdp # VSX Vector Convert Signed Word to Double-Precision format
XVCVSXWDP PPC64LE 111100 t:5 00000 b:5 01111 1000 bx:1 tx:1

@ format:XX2, book:I, page:872, Vector-Scalar_Extension, v2.06, xvcvsxwsp # VSX Vector Convert with round Signed Word to Single-Precision format
XVCVSXWSP PPC64LE 111100 t:5 00000 b:5 01011 1000 bx:1 tx:1

@ format:XX2, book:I, page:873, Vector-Scalar_Extension, v2.06, xvcvuxddp # VSX Vector Convert with round Unsigned Doubleword to Double-Precision format
XVCVUXDDP PPC64LE 111100 t:5 00000 b:5 11110 1000 bx:1 tx:1

@ format:XX2, book:I, page:874, Vector-Scalar_Extension, v2.06, xvcvuxdsp # VSX Vector Convert with round Unsigned Doubleword to Single-Precision format
XVCVUXDSP PPC64LE 111100 t:5 00000 b:5 11010 1000 bx:1 tx:1

@ format:XX2, book:I, page:875, Vector-Scalar_Extension, v2.06, xvcvuxwdp # VSX Vector Convert Unsigned Word to Double-Precision format
XVCVUXWDP PPC64LE 111100 t:5 00000 b:5 01110 1000 bx:1 tx:1

@ format:XX2, book:I, page:875, Vector-Scalar_Extension, v2.06, xvcvuxwsp # VSX Vector Convert with round Unsigned Word to Single-Precision format
XVCVUXWSP PPC64LE 111100 t:5 00000 b:5 01010 1000 bx:1 tx:1

@ format:XX3, book:I, page:876, Vector-Scalar_Extension, v2.06, xvdivdp # VSX Vector Divide Double-Precision
XVDIVDP PPC64LE 111100 t:5 a:5 b:5 01111000 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:878, Vector-Scalar_Extension, v2.06, xvdivsp # VSX Vector Divide Single-Precision
XVDIVSP PPC64LE 111100 t:5 a:5 b:5 01011000 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:880, Vector-Scalar_Extension, v3.1, MMA, Skip, xvf16ger2 # VSX Vector 16-bit Floating-Point GER (rank-2 update)
XVF16GER2 PPC64LE 111011 a:3 00 b:10 00010011 c:2 0

@ format:XX3, book:I, page:880, Vector-Scalar_Extension, v3.1, MMA, Skip, xvf16ger2nn # VSX Vector 16-bit Floating-Point GER (rank-2 update) Negative multiply, Negative accumulate
XVF16GER2NN PPC64LE 111011 a:3 00 b:10 11010010 c:2 0

@ format:XX3, book:I, page:880, Vector-Scalar_Extension, v3.1, MMA, Skip, xvf16ger2np # VSX Vector 16-bit Floating-Point GER (rank-2 update) Negative multiply, Positive accumulate
XVF16GER2NP PPC64LE 111011 a:3 00 b:10 01010010 c:2 0

@ format:XX3, book:I, page:880, Vector-Scalar_Extension, v3.1, MMA, Skip, xvf16ger2pn # VSX Vector 16-bit Floating-Point GER (rank-2 update) Positive multiply, Negative accumulate
XVF16GER2PN PPC64LE 111011 a:3 00 b:10 10010010 c:2 0

@ format:XX3, book:I, page:880, Vector-Scalar_Extension, v3.1, MMA, Skip, xvf16ger2pp # VSX Vector 16-bit Floating-Point GER (rank-2 update) Positive multiply, Positive accumulate
XVF16GER2PP PPC64LE 111011 a:3 00 b:10 00010010 c:2 0

@ format:XX3, book:I, page:884, Vector-Scalar_Extension, v3.1, MMA, Skip, xvf32ger # VSX Vector 32-bit Floating-Point GER (rank-1 update)
XVF32GER PPC64LE 111011 a:3 00 b:10 00011011 c:2 0

@ format:XX3, book:I, page:884, Vector-Scalar_Extension, v3.1, MMA, Skip, xvf32gernn # VSX Vector 32-bit Floating-Point GER (rank-1 update) Negative multiply, Negative accumulate
XVF32GERNN PPC64LE 111011 a:3 00 b:10 11011010 c:2 0

@ format:XX3, book:I, page:884, Vector-Scalar_Extension, v3.1, MMA, Skip, xvf32gernp # VSX Vector 32-bit Floating-Point GER (rank-1 update) Negative multiply, Positive accumulate
XVF32GERNP PPC64LE 111011 a:3 00 b:10 01011010 c:2 0

@ format:XX3, book:I, page:884, Vector-Scalar_Extension, v3.1, MMA, Skip, xvf32gerpn # VSX Vector 32-bit Floating-Point GER (rank-1 update) Positive multiply, Negative accumulate
XVF32GERPN PPC64LE 111011 a:3 00 b:10 10011010 c:2 0

@ format:XX3, book:I, page:884, Vector-Scalar_Extension, v3.1, MMA, Skip, xvf32gerpp # VSX Vector 32-bit Floating-Point GER (rank-1 update) Positive multiply, Positive accumulate
XVF32GERPP PPC64LE 111011 a:3 00 b:10 00011010 c:2 0

@ format:XX3, book:I, page:888, Vector-Scalar_Extension, v3.1, MMA, Skip, xvf64ger # VSX Vector 64-bit Floating-Point GER (rank-1 update)
XVF64GER PPC64LE 111011 a:3 00 b:10 00111011 c:2 0

@ format:XX3, book:I, page:888, Vector-Scalar_Extension, v3.1, MMA, Skip, xvf64gernn # VSX Vector 64-bit Floating-Point GER (rank-1 update) Negative multiply, Negative accumulate
XVF64GERNN PPC64LE 111011 a:3 00 b:10 11111010 c:2 0

@ format:XX3, book:I, page:888, Vector-Scalar_Extension, v3.1, MMA, Skip, xvf64gernp # VSX Vector 64-bit Floating-Point GER (rank-1 update) Negative multiply, Positive accumulate
XVF64GERNP PPC64LE 111011 a:3 00 b:10 01111010 c:2 0

@ format:XX3, book:I, page:888, Vector-Scalar_Extension, v3.1, MMA, Skip, xvf64gerpn # VSX Vector 64-bit Floating-Point GER (rank-1 update) Positive multiply, Negative accumulate
XVF64GERPN PPC64LE 111011 a:3 00 b:10 10111010 c:2 0

@ format:XX3, book:I, page:888, Vector-Scalar_Extension, v3.1, MMA, Skip, xvf64gerpp # VSX Vector 64-bit Floating-Point GER (rank-1 update) Positive multiply, Positive accumulate
XVF64GERPP PPC64LE 111011 a:3 00 b:10 00111010 c:2 0

@ format:XX3, book:I, page:900, Vector-Scalar_Extension, v3.1, MMA, Skip, xvi16ger2 # VSX Vector 16-bit Signed Integer GER (rank-2 update)
XVI16GER2 PPC64LE 111011 a:3 00 b:10 01001011 c:2 0

@ format:XX3, book:I, page:900, Vector-Scalar_Extension, v3.1, MMA, Skip, xvi16ger2pp # VSX Vector 16-bit Signed Integer GER (rank-2 update) Positive multiply, Positive accumulate
XVI16GER2PP PPC64LE 111011 a:3 00 b:10 01101011 c:2 0

@ format:XX3, book:I, page:902, Vector-Scalar_Extension, v3.1, MMA, Skip, xvi16ger2s # VSX Vector 16-bit Signed Integer GER (rank-2 update) with Saturation
XVI16GER2S PPC64LE 111011 a:3 00 b:10 00101011 c:2 0

@ format:XX3, book:I, page:902, Vector-Scalar_Extension, v3.1, MMA, Skip, xvi16ger2spp # VSX Vector 16-bit Signed Integer GER (rank-2 update) with Saturation Positive multiply, Positive accumulate
XVI16GER2SPP PPC64LE 111011 a:3 00 b:10 00101010 c:2 0

@ format:XX3, book:I, page:892, Vector-Scalar_Extension, v3.1, MMA, Skip, xvi4ger8 # VSX Vector 4-bit Signed Integer GER (rank-8 update)
XVI4GER8 PPC64LE 111011 a:3 00 b:10 00100011 c:2 0

@ format:XX3, book:I, page:892, Vector-Scalar_Extension, v3.1, MMA, Skip, xvi4ger8pp # VSX Vector 4-bit Signed Integer GER (rank-8 update) Positive multiply, Positive accumulate
XVI4GER8PP PPC64LE 111011 a:3 00 b:10 00100010 c:2 0

@ format:XX3, book:I, page:895, Vector-Scalar_Extension, v3.1, MMA, Skip, xvi8ger4 # VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update)
XVI8GER4 PPC64LE 111011 a:3 00 b:10 00000011 c:2 0

@ format:XX3, book:I, page:895, Vector-Scalar_Extension, v3.1, MMA, Skip, xvi8ger4pp # VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update) Positive multiply, Positive accumulate
XVI8GER4PP PPC64LE 111011 a:3 00 b:10 00000010 c:2 0

@ format:XX3, book:I, page:898, Vector-Scalar_Extension, v3.1, MMA, Skip, xvi8ger4spp # VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update) with Saturate Positive multiply, Positive accumulate
XVI8GER4SPP PPC64LE 111011 a:3 00 b:10 01100011 c:2 0

@ format:XX3, book:I, page:905, Vector-Scalar_Extension, v3.0, xviexpdp # VSX Vector Insert Exponent Double-Precision
XVIEXPDP PPC64LE 111100 t:5 a:5 b:5 11111000 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:905, Vector-Scalar_Extension, v3.0, xviexpsp # VSX Vector Insert Exponent Single-Precision
XVIEXPSP PPC64LE 111100 t:5 a:5 b:5 11011000 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:906, Vector-Scalar_Extension, v2.06, xvmaddadp # VSX Vector Multiply-Add Type-A Double-Precision
XVMADDADP PPC64LE 111100 t:5 a:5 b:5 01100001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:909, Vector-Scalar_Extension, v2.06, xvmaddasp # VSX Vector Multiply-Add Type-A Single-Precision
XVMADDASP PPC64LE 111100 t:5 a:5 b:5 01000001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:906, Vector-Scalar_Extension, v2.06, xvmaddmdp # VSX Vector Multiply-Add Type-M Double-Precision
XVMADDMDP PPC64LE 111100 t:5 a:5 b:5 01101001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:909, Vector-Scalar_Extension, v2.06, xvmaddmsp # VSX Vector Multiply-Add Type-M Single-Precision
XVMADDMSP PPC64LE 111100 t:5 a:5 b:5 01001001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:912, Vector-Scalar_Extension, v2.06, xvmaxdp # VSX Vector Maximum Double-Precision
XVMAXDP PPC64LE 111100 t:5 a:5 b:5 11100000 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:914, Vector-Scalar_Extension, v2.06, xvmaxsp # VSX Vector Maximum Single-Precision
XVMAXSP PPC64LE 111100 t:5 a:5 b:5 11000000 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:916, Vector-Scalar_Extension, v2.06, xvmindp # VSX Vector Minimum Double-Precision
XVMINDP PPC64LE 111100 t:5 a:5 b:5 11101000 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:918, Vector-Scalar_Extension, v2.06, xvminsp # VSX Vector Minimum Single-Precision
XVMINSP PPC64LE 111100 t:5 a:5 b:5 11001000 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:920, Vector-Scalar_Extension, v2.06, xvmsubadp # VSX Vector Multiply-Subtract Type-A Double-Precision
XVMSUBSDP PPC64LE 111100 t:5 a:5 b:5 01110001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:923, Vector-Scalar_Extension, v2.06, xvmsubasp # VSX Vector Multiply-Subtract Type-A Single-Precision
XVMSUBASP PPC64LE 111100 t:5 a:5 b:5 01010001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:920, Vector-Scalar_Extension, v2.06, xvmsubmdp # VSX Vector Multiply-Subtract Type-M Double-Precision
XVMSUBMDP PPC64LE 111100 t:5 a:5 b:5 01111001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:923, Vector-Scalar_Extension, v2.06, xvmsubmsp # VSX Vector Multiply-Subtract Type-M Single-Precision
XMVSUBMSP PPC64LE 111100 t:5 a:5 b:5 01011001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:926, Vector-Scalar_Extension, v2.06, xvmuldp # VSX Vector Multiply Double-Precision
XVMULDP PPC64LE 111100 t:5 a:5 b:5 01110000 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:928, Vector-Scalar_Extension, v2.06, xvmulsp # VSX Vector Multiply Single-Precision
XVMULSP PPC64LE 111100 t:5 a:5 b:5 01010000 ax:1 bx:1 tx:1

@ format:XX2, book:I, page:930, Vector-Scalar_Extension, v2.06, xvnabsdp # VSX Vector Negative Absolute Double-Precision
XVNABSDP PPC64LE 111100 t:5 00000 b:5 11110 1001 bx:1 tx:1

@ format:XX2, book:I, page:930, Vector-Scalar_Extension, v2.06, xvnabssp # VSX Vector Negative Absolute Single-Precision
XVNABSSP PPC64LE 111100 t:5 00000 b:5 11010 1001 bx:1 tx:1

@ format:XX2, book:I, page:931, Vector-Scalar_Extension, v2.06, xvnegdp # VSX Vector Negate Double-Precision
XVNEGDP PPC64LE 111100 t:5 00000 b:5 11111 1001 bx:1 tx:1

@ format:XX2, book:I, page:931, Vector-Scalar_Extension, v2.06, xvnegsp # VSX Vector Negate Single-Precision
XVNEGSP PPC64LE 111100 t:5 00000 b:5 11011 1001 bx:1 tx:1

@ format:XX3, book:I, page:932, Vector-Scalar_Extension, v2.06, xvnmaddadp # VSX Vector Negative Multiply-Add Type-A Double-Precision
XVNMADDADP PPC64LE 111100 t:5 a:5 b:5 11100001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:936, Vector-Scalar_Extension, v2.06, xvnmaddasp # VSX Vector Negative Multiply-Add Type-A Single-Precision
XVNMADDASP PPC64LE 111100 t:5 a:5 b:5 11000001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:932, Vector-Scalar_Extension, v2.06, xvnmaddmdp # VSX Vector Negative Multiply-Add Type-M Double-Precision
XVNMADDMDP PPC64LE 111100 t:5 a:5 b:5 11101001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:936, Vector-Scalar_Extension, v2.06, xvnmaddmsp # VSX Vector Negative Multiply-Add Type-M Single-Precision
XVNMADDMSP PPC64LE 111100 t:5 a:5 b:5 11001001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:939, Vector-Scalar_Extension, v2.06, xvnmsubadp # VSX Vector Negative Multiply-Subtract Type-A Double-Precision
XVNMSUBADP PPC64LE 111100 t:5 a:5 b:5 11110001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:942, Vector-Scalar_Extension, v2.06, xvnmsubasp # VSX Vector Negative Multiply-Subtract Type-A Single-Precision
XVNMSUBASP PPC64LE 111100 t:5 a:5 b:5 11010001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:939, Vector-Scalar_Extension, v2.06, xvnmsubmdp # VSX Vector Negative Multiply-Subtract Type-M Double-Precision
XVNMSUBMDP PPC64LE 111100 t:5 a:5 b:5 11111001 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:942, Vector-Scalar_Extension, v2.06, xvnmsubmsp # VSX Vector Negative Multiply-Subtract Type-M Single-Precision
XVNMSUBMSP PPC64LE 111100 t:5 a:5 b:5 11011001 ax:1 bx:1 tx:1

@ format:XX2, book:I, page:945, Vector-Scalar_Extension, v2.06, xvrdpi # VSX Vector Round to Double-Precision Integer using round to Nearest Away
XVRDPI PPC64LE 111100 t:5 00000 b:5 01100 1001 bx:1 tx:1

@ format:XX2, book:I, page:946, Vector-Scalar_Extension, v2.06, xvrdpic # VSX Vector Round to Double-Precision Integer Exact using Current rounding mode
XVRDPIC PPC64LE 111100 t:5 00000 b:5 01110 1011 bx:1 tx:1

@ format:XX2, book:I, page:947, Vector-Scalar_Extension, v2.06, xvrdpim # VSX Vector Round to Double-Precision Integer using round toward -Infinity
XVRDPIM PPC64LE 111100 t:5 00000 b:5 01111 1001 bx:1 tx:1

@ format:XX2, book:I, page:948, Vector-Scalar_Extension, v2.06, xvrdpip # VSX Vector Round to Double-Precision Integer using round toward +Infinity
XVRDPIP PPC64LE 111100 t:5 00000 b:5 01110 1001 bx:1 tx:1

@ format:XX2, book:I, page:948, Vector-Scalar_Extension, v2.06, xvrdpiz # VSX Vector Round to Double-Precision Integer using round toward Zero
XVRDPIZ PPC64LE 111100 t:5 00000 b:5 01101 1001 bx:1 tx:1

@ format:XX2, book:I, page:949, Vector-Scalar_Extension, v2.06, xvredp # VSX Vector Reciprocal Estimate Double-Precision
XVREDP PPC64LE 111100 t:5 00000 b:5 01101 1010 bx:1 tx:1

@ format:XX2, book:I, page:950, Vector-Scalar_Extension, v2.06, xvresp # VSX Vector Reciprocal Estimate Single-Precision
XVRESP PPC64LE 111100 t:5 00000 b:5 01001 1010 bx:1 tx:1

@ format:XX2, book:I, page:951, Vector-Scalar_Extension, v2.06, xvrspi # VSX Vector Round to Single-Precision Integer using round to Nearest Away
XVRSPI PPC64LE 111100 t:5 00000 b:5 01000 1001 bx:1 tx:1

@ format:XX2, book:I, page:952, Vector-Scalar_Extension, v2.06, xvrspic # VSX Vector Round to Single-Precision Integer Exact using Current rounding mode
XVRSPIC PPC64LE 111100 t:5 00000 b:5 01010 1011 bx:1 tx:1

@ format:XX2, book:I, page:953, Vector-Scalar_Extension, v2.06, xvrspim # VSX Vector Round to Single-Precision Integer using round toward -Infinity
XVRSPIM PPC64LE 111100 t:5 00000 b:5 01011 1001 bx:1 tx:1

@ format:XX2, book:I, page:954, Vector-Scalar_Extension, v2.06, xvrspip # VSX Vector Round to Single-Precision Integer using round toward +Infinity
XVRSPIP PPC64LE 111100 t:5 00000 b:5 01010 1001 bx:1 tx:1

@ format:XX2, book:I, page:954, Vector-Scalar_Extension, v2.06, xvrspiz # VSX Vector Round to Single-Precision Integer using round toward Zero
XVRSPIZ PPC64LE 111100 t:5 00000 b:5 01001 1001 bx:1 tx:1

@ format:XX2, book:I, page:955, Vector-Scalar_Extension, v2.06, xvrsqrtedp # VSX Vector Reciprocal Square Root Estimate Double-Precision
XVRSQRTEDP PPC64LE 111100 t:5 00000 b:5 01100 1010 bx:1 tx:1

@ format:XX2, book:I, page:956, Vector-Scalar_Extension, v2.06, xvrsqrtesp # VSX Vector Reciprocal Square Root Estimate Single-Precision
XVRSQRTESP PPC64LE 111100 t:5 00000 b:5 01000 1010 bx:1 tx:1

@ format:XX2, book:I, page:957, Vector-Scalar_Extension, v2.06, xvsqrtdp # VSX Vector Square Root Double-Precision
XVSQRTDP PPC64LE 111100 t:5 00000 b:5 01100 1011 bx:1 tx:1

@ format:XX2, book:I, page:958, Vector-Scalar_Extension, v2.06, xvsqrtsp # VSX Vector Square Root Single-Precision
XVSQRTSP PPC64LE 111100 t:5 00000 b:5 01000 1011 bx:1 tx:1

@ format:XX3, book:I, page:959, Vector-Scalar_Extension, v2.06, xvsubdp # VSX Vector Subtract Double-Precision
XVSUBDP PPC64LE 111100 t:5 a:5 b:5 01101000 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:961, Vector-Scalar_Extension, v2.06, xvsubsp # VSX Vector Subtract Single-Precision
XVSUBSP PPC64LE 111100 t:5 a:5 b:5 01001000 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:963, Vector-Scalar_Extension, v2.06, xvtdivdp # VSX Vector Test for software Divide Double-Precision
XVTDIVDP PPC64LE 111100 bf:3 00 a:5 b:5 01111101 ax:1 bx:1 0

@ format:XX3, book:I, page:964, Vector-Scalar_Extension, v2.06, xvtdivsp # VSX Vector Test for software Divide Single-Precision
XVTDIVSP PPC64LE 111100 bf:3 00 a:5 b:5 01011101 ax:1 bx:1 0

@ format:XX2, book:I, page:968, Vector-Scalar_Extension, v3.1, Skip, xvtlsbb # VSX Vector Test Least-Significant Bit by Byte
XVTLSBB PPC64LE 111100 a:3 0000010 b:5 111011011 c:1 0

@ format:XX2, book:I, page:965, Vector-Scalar_Extension, v2.06, xvtsqrtdp # VSX Vector Test for software Square Root Double-Precision
XVTSQRTDP PPC64LE 111100 bf:3 0000000 b:5 011101010 bx:1 0

@ format:XX2, book:I, page:965, Vector-Scalar_Extension, v2.06, xvtsqrtsp # VSX Vector Test for software Square Root Single-Precision
XVTSQRTSP PPC64LE 111100 bf:3 0000000 b:5 010101010 bx:1 0

@ format:XX2, book:I, page:966, Vector-Scalar_Extension, v3.0, xvtstdcdp # VSX Vector Test Data Class Double-Precision
XVTSTDCDP PPC64LE 111100 t:5 dx:5 b:5 1111 dc:1 101 dm:1 bx:1 tx:1

@ format:XX2, book:I, page:967, Vector-Scalar_Extension, v3.0, xvtstdcsp # VSX Vector Test Data Class Single-Precision
XVTSTDCSP PPC64LE 111100 t:5 dx:5 b:5 1101 dc:1 101 dm:1 bx:1 tx:1

@ format:XX2, book:I, page:969, Vector-Scalar_Extension, v3.0, xvxexpdp # VSX Vector Extract Exponent Double-Precision
XVXEXPDP PPC64LE 111100 t:5 00000 b:5 111011011 bx:1 tx:1

@ format:XX2, book:I, page:969, Vector-Scalar_Extension, v3.0, xvxexpsp # VSX Vector Extract Exponent Single-Precision
XVXEXPSP PPC64LE 111100 t:5 01000 b:5 111011011 bx:1 tx:1

@ format:XX2, book:I, page:970, Vector-Scalar_Extension, v3.0, xvxsigdp # VSX Vector Extract Significand Double-Precision
XVXSIGDP PPC64LE 111100 t:5 00001 b:5 111011011 bx:1 tx:1

@ format:XX2, book:I, page:970, Vector-Scalar_Extension, v3.0, xvxsigsp # VSX Vector Extract Significand Single-Precision
XVXSIGSP PPC64LE 111100 t:5 01001 b:5 111011011 bx:1 tx:1

@ format:8RR:XX4, book:I, page:971, Vector-Scalar_Extension, v3.1, Skip, xxblendvb # VSX Vector Blend Variable Byte
XXBLENDVB PPC64LE 00000101000000000000000000000000100001 a:20 00 b:4

@ format:8RR:XX4, book:I, page:972, Vector-Scalar_Extension, v3.1, Skip, xxblendvd # VSX Vector Blend Variable Doubleword
XXBLENDVD PPC64LE 00000101000000000000000000000000100001 a:20 11 b:4

@ format:8RR:XX4, book:I, page:971, Vector-Scalar_Extension, v3.1, Skip, xxblendvh # VSX Vector Blend Variable Halfword
XXBLENDVH PPC64LE 00000101000000000000000000000000100001 a:20 01 b:4

@ format:8RR:XX4, book:I, page:972, Vector-Scalar_Extension, v3.1, Skip, xxblendvw # VSX Vector Blend Variable Word
XXBLENDVW PPC64LE 00000101000000000000000000000000100001 a:20 10 b:4

@ format:XX2, book:I, page:973, Vector-Scalar_Extension, v3.0, xxbrd # VSX Vector Byte-Reverse Doubleword
XXBRD PPC64LE 111100 t:5 10111 b:5 111011011 bx:1 tx:1

@ format:XX2, book:I, page:974, Vector-Scalar_Extension, v3.0, xxbrh # VSX Vector Byte-Reverse Halfword
XXBRH PPC64LE 111100 t:5 00111 b:5 111011011 bx:1 tx:1

@ format:XX2, book:I, page:975, Vector-Scalar_Extension, v3.0, xxbrq # VSX Vector Byte-Reverse Quadword
XXBRQ PPC64LE 111100 t:5 11111 b:5 111011011 bx:1 tx:1

@ format:XX2, book:I, page:976, Vector-Scalar_Extension, v3.0, xxbrw # VSX Vector Byte-Reverse Word
XXBRW PPC64LE 111100 t:5 01111 b:5 111011011 bx:1 tx:1

@ format:8RR-XX4, book:I, page:976, Vector-Scalar_Extension, v3.1, Skip, xxeval # VSX Vector Evaluate
XXEVAL PPC64LE 000001010000000000000000 a:8 100010 b:20 01 c:4

@ format:XX2, book:I, page:978, Vector-Scalar_Extension, v3.0, xxextractuw # VSX Vector Extract Unsigned Word
XXEXTRACTUW PPC64LE 111100 t:5 0 uim:4 b:5 010100101 bx:1 tx:1

@ format:X, book:I, page:979, Vector-Scalar_Extension, v3.1, Skip, xxgenpcvbm # VSX Vector Generate PCV from Byte Mask
XXGENPCVBM PPC64LE 111100 a:15 1110010100 rc:1

@ format:X, book:I, page:985, Vector-Scalar_Extension, v3.1, Skip, xxgenpcvdm # VSX Vector Generate PCV from Doubleword Mask
XXGENPCVDM PPC64LE 111100 a:15 1110110101 rc:1

@ format:X, book:I, page:981, Vector-Scalar_Extension, v3.1, Skip, xxgenpcvhm # VSX Vector Generate PCV from Halfword Mask
XXGENPCVHM PPC64LE 111100 a:15 1110010101 rc:1

@ format:X, book:I, page:983, Vector-Scalar_Extension, v3.1, Skip, xxgenpcvwm # VSX Vector Generate PCV from Word Mask
XXGENPCVWM PPC64LE 111100 a:15 1110110100 rc:1

@ format:XX2, book:I, page:978, Vector-Scalar_Extension, v3.0, xxinsertw # VSX Vector Insert Word
XXINSERTW PPC64LE 111100 t:5 0 uim:4 b:5 010110101 bx:1 tx:1

@ format:XX3, book:I, page:988, Vector-Scalar_Extension, v2.06, xxland # VSX Vector Logical AND
XXLAND PPC64LE 111100 t:5 a:5 b:5 10000010 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:988, Vector-Scalar_Extension, v2.06, xxlandc # VSX Vector Logical AND with Complement
XXLANDC PPC64LE 111100 t:5 a:5 b:5 10001010 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:989, Vector-Scalar_Extension, v2.07, xxleqv # VSX Vector Logical Equivalence
XXLEQV PPC64LE 111100 t:5 a:5 b:5 10111010 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:989, Vector-Scalar_Extension, v2.07, xxlnand # VSX Vector Logical NAND
XXLNAND PPC64LE 111100 t:5 a:5 b:5 10110010 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:990, Vector-Scalar_Extension, v2.06, xxlnor # VSX Vector Logical NOR
XXLNOR PPC64LE 111100 t:5 a:5 b:5 10100010 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:991, Vector-Scalar_Extension, v2.06, xxlor # VSX Vector Logical OR
XXLOR PPC64LE 111100 t:5 a:5 b:5 10010010 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:990, Vector-Scalar_Extension, v2.07, xxlorc # VSX Vector Logical OR with Complement
XXLORC PPC64LE 111100 t:5 a:5 b:5 10101010 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:991, Vector-Scalar_Extension, v2.06, xxlxor # VSX Vector Logical XOR
XXLXOR PPC64LE 111100 t:5 a:5 b:5 10011010 ax:1 bx:1 tx:1

@ format:X, book:I, page:993, Vector-Scalar_Extension, v3.1, MMA, Skip, xxmfacc # VSX Move FromAccumulator
XXMFACC PPC64LE 011111 a:3 00000000000000101100010

@ format:XX3, book:I, page:992, Vector-Scalar_Extension, v2.06, xxmrghw # VSX Vector Merge High Word
XXMRGHW PPC64LE 111100 t:5 a:5 b:5 00010010 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:992, Vector-Scalar_Extension, v2.06, xxmrglw # VSX Vector Merge Low Word
XXMRGLW PPC64LE 111100 t:5 a:5 b:5 00110010 ax:1 bx:1 tx:1

@ format:X, book:I, page:994, Vector-Scalar_Extension, v3.1, MMA, Skip, xxmtacc # VSX Move To Accumulator
XXMTACC PPC64LE 011111 a:3 00000010000000101100010

@ format:XX3, book:I, page:995, Vector-Scalar_Extension, v3.0, xxperm # VSX Vector Permute
XXPERM PPC64LE 111100 t:5 a:5 b:5 00011010 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:996, Vector-Scalar_Extension, v2.06, xxpermdi # VSX Vector Permute Doubleword Immediate
XXPERMDI PPC64LE 111100 t:5 a:5 b:5 0 dm:2 01010 ax:1 bx:1 tx:1

@ format:XX3, book:I, page:995, Vector-Scalar_Extension, v3.0, xxpermr # VSX Vector Permute Right-indexed
XXPERMR PPC64LE 111100 t:5 a:5 b:5 00111010 ax:1 bx:1 tx:1

@ format:8RR:XX4, book:I, page:997, Vector-Scalar_Extension, v3.1, Skip, xxpermx # VSX Vector Permute Extended
XXPERMX PPC64LE 00000101000000000000000000000 a:3 100010 b:20 00 c:4

@ format:XX4, book:I, page:998, Vector-Scalar_Extension, v2.06, xxsel # VSX Vector Select
XXSEL PPC64LE 111100 t:5 a:5 b:5 c:5 11 cx:1 ax:1 bx:1 tx:1

@ format:X, book:I, page:999, Vector-Scalar_Extension, v3.1, MMA, Skip, xxsetaccz # VSX Set Accumulator to Zero
XXSETACCZ PPC64LE 011111 a:3 00000110000000101100010

@ format:XX3, book:I, page:1000, Vector-Scalar_Extension, v2.06, xxsldwi # VSX Vector Shift Left Double by Word Immediate
XXSLDWI PPC64LE 111100 t:5 a:5 b:5 0 shw:2 00010 ax:1 bx:1 tx:1

@ format:8RR:D, book:I, page:1002, Vector-Scalar_Extension, v3.1, Skip, xxsplti32dx # VSX Vector Splat Immediate32 Doubleword Indexed
XXSPLTI32DX PPC64LE 0000010100000000 a:16 100000 b:5 000 c:18

@ format:X, book:I, page:1001, Vector-Scalar_Extension, v3.0, xxspltib # VSX Vector Splat Immediate Byte
XXSPLTIB PPC64LE 111100 t:5 00 imm:8 0101101000 tx:1

@ format:8RR:D, book:I, page:1001, Vector-Scalar_Extension, v3.1, Skip, xxspltidp # VSX Vector Splat Immediate Double-Precision
XXSPLTIDP PPC64LE 0000010100000000 a:16 100000 b:5 0010 c:17

@ format:8RR:D, book:I, page:1002, Vector-Scalar_Extension, v3.1, Skip, xxspltiw # VSX Vector Splat Immediate Word
XXSPLTIW PPC64LE 0000010100000000 a:16 100000 b:5 0011 c:17

@ format:XX2, book:I, page:1003, Vector-Scalar_Extension, v2.06, xxspltw # VSX Vector Splat Word
XXSPLTW PPC64LE 111100 t:5 000 uim:2 b:5 010100100 bx:1 tx:1
